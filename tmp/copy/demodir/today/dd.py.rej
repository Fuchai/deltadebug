--- /home/jasonhu/Desktop/pydd/tmp/copy/demodir/today/dd.py	2020-03-27 23:28:23.049670193 -0500
+++ /home/jasonhu/Desktop/pydd/tmp/copy/demodir/today/dd.py	2020-03-27 23:28:23.049670193 -0500
@@ -15,22 +15,11 @@
         self.debug_flag = False
 
     def pre_run(self):
-        """
-        run the test binary on yesterday and today to check the properties
-
-        :return:
-        """
         ytd_ret = self.test_ytd()
         today_ret = self.test_today()
 
-        assert ytd_ret == 0, "Yesterday's code did not work?"
-        assert today_ret == 1, "Today's code did not break?"
 
     def test_ytd(self):
-        """
-        Test yesterday's directory. Patches are applied to yesterday, so it will be used to test patched code
-        :return:
-        """
         ytd_run = subprocess.run([str(self.test_binary), str(self.yesterday_directory)])
         if self.debug_flag:
             print("yesterday test return code", ytd_run.returncode)
@@ -74,13 +63,7 @@
             print("The minimal patch is created at location", minimal_patch_path)
 
     def algo1(self, patches, fixed):
-        """
-        Algorithm 1 presented in the paper. Does not handle inconsistencies.
 
-        :param patches: The set of patches. c in paper.
-        :param fixed: The fixed changes that will be applied to the subset. r in paper.
-        :return: A possibly smaller set of patches.
-        """
         if len(patches) == 1:
             return patches
 
@@ -94,13 +77,8 @@
 
         if self.debug_flag:
             print(incrementals)
+        minimal_patches = self.algo1(incrementals, set())
 
-        if algo==1:
-            minimal_patches = self.algo1(incrementals, set())
-        elif algo==2:
-            minimal_patches = self.algo2(incrementals, set(), 2)
-        else:
-            raise Exception("Your algorithm choice is not supported, only 1 or 2")
 
         if self.debug_flag:
             print(minimal_patches)
@@ -133,25 +111,6 @@
                 if complement_tis == 0 and tis[i] == 0:
                     return self.algo2(ci, complement | fixed, 2) | self.algo2(complement, ci | fixed, 2)
 
-        #
-        #
-        #     if tis[0] == 0 and tis[1] == 0:
-        #         return self.algo2(cis[0], cis[1] | fixed, 2) | self.algo2(cis[1], cis[0] | fixed, 2)
-        # else:
-        #     complements = [set(patches) - ci for ci in cis]
-        #     for i, complement in enumerate(complements):
-        #         ci = cis[i]
-        #         if self.test_patches(complement) == 0 and tis[i] == 0:
-        #             return self.algo2(ci, complement | fixed, 2) | self.algo2(complement, ci | fixed, 2)
-
-        # case 4
-        # if n == 2:
-        #     if tis[0] == -1 and tis[1] == 0:
-        #         return self.algo2(cis[0], cis[1] | fixed, 2)
-        #     elif tis[0] == 0 and tis[1] == -1:
-        #         return self.algo2(cis[1], cis[0]|fixed, 2)
-        # else:
-
         # case 4
         for i, complement in enumerate(complements):
             ci = cis[i]
@@ -236,13 +195,9 @@
     yd = "patches/expcp"
     td = "patches/expcp2"
     root = "patches"
-    # yd = "/home/jasonhu/Desktop/rootdir/today"
-    # td = "/home/jasonhu/Desktop/rootdir/yesterday"
-    # root = "/home/jasonhu/Desktop/rootdir"
-
     delta = Delta(tb, root, yd, td)
     delta.pre_run()
-    delta.debug(algo=1)
+    delta.debug()
 
 
 def main():
