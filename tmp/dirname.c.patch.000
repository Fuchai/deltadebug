--- dbg/find14/find/gnulib-cvs/gnulib/lib/dirname.c	2020-01-28 23:47:42.000000000 -0600
+++ dbg/find6/find/gnulib-cvs/gnulib/lib/dirname.c	2020-01-28 23:39:42.000000000 -0600
@@ -1,6 +1,6 @@
-/* dirname.c -- return all but the last element in a path
+/* dirname.c -- return all but the last element in a file name
 
-   Copyright (C) 1990, 1998, 2000, 2001, 2003, 2004 Free Software
+   Copyright (C) 1990, 1998, 2000, 2001, 2003, 2004, 2005, 2006 Free Software
    Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
@@ -15,107 +15,71 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software Foundation,
-   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
 
-#if HAVE_CONFIG_H
-# include <config.h>
-#endif
+#include <config.h>
 
 #include "dirname.h"
 
 #include <string.h>
 #include "xalloc.h"
 
-/* Return the length of `dirname (PATH)', or zero if PATH is
-   in the working directory.  Works properly even if
-   there are trailing slashes (by effectively ignoring them).  */
+/* Return the length of the prefix of FILE that will be used by
+   dir_name.  If FILE is in the working directory, this returns zero
+   even though `dir_name (FILE)' will return ".".  Works properly even
+   if there are trailing slashes (by effectively ignoring them).  */
+
 size_t
-dir_len (char const *path)
+dir_len (char const *file)
 {
-  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (path);
+  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);
   size_t length;
 
-  /* Strip the basename and any redundant slashes before it.  */
-  for (length = base_name (path) - path;  prefix_length < length;  length--)
-    if (! ISSLASH (path[length - 1]))
-      return length;
+  /* Advance prefix_length beyond important leading slashes.  */
+  prefix_length += (prefix_length != 0
+		    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE
+		       && ISSLASH (file[prefix_length]))
+		    : (ISSLASH (file[0])
+		       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT
+			   && ISSLASH (file[1]) && ! ISSLASH (file[2])
+			   ? 2 : 1))
+		       : 0));
 
-  /* But don't strip the only slash from "/".  */
-  return prefix_length + ISSLASH (path[prefix_length]);
+  /* Strip the basename and any redundant slashes before it.  */
+  for (length = last_component (file) - file;
+       prefix_length < length; length--)
+    if (! ISSLASH (file[length - 1]))
+      break;
+  return length;
 }
 
-/* Return the leading directories part of PATH,
-   allocated with xmalloc.
-   Works properly even if there are trailing slashes
-   (by effectively ignoring them).  */
+
+/* In general, we can't use the builtin `dirname' function if available,
+   since it has different meanings in different environments.
+   In some environments the builtin `dirname' modifies its argument.
+
+   Return the leading directories part of FILE, allocated with xmalloc.
+   Works properly even if there are trailing slashes (by effectively
+   ignoring them).  Unlike POSIX dirname(), FILE cannot be NULL.
+
+   If lstat (FILE) would succeed, then { chdir (dir_name (FILE));
+   lstat (base_name (FILE)); } will access the same file.  Likewise,
+   if the sequence { chdir (dir_name (FILE));
+   rename (base_name (FILE), "foo"); } succeeds, you have renamed FILE
+   to "foo" in the same directory FILE was in.  */
 
 char *
-dir_name (char const *path)
+dir_name (char const *file)
 {
-  size_t length = dir_len (path);
-  bool append_dot = (length == FILE_SYSTEM_PREFIX_LEN (path));
-  char *newpath = xmalloc (length + append_dot + 1);
-  memcpy (newpath, path, length);
+  size_t length = dir_len (file);
+  bool append_dot = (length == 0
+		     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE
+			 && length == FILE_SYSTEM_PREFIX_LEN (file)
+			 && file[2] != '\0' && ! ISSLASH (file[2])));
+  char *dir = xmalloc (length + append_dot + 1);
+  memcpy (dir, file, length);
   if (append_dot)
-    newpath[length++] = '.';
-  newpath[length] = 0;
-  return newpath;
-}
-
-#ifdef TEST_DIRNAME
-/*
-
-Run the test like this (expect no output):
-  gcc -DHAVE_CONFIG_H -DTEST_DIRNAME -I.. -O -Wall \
-     basename.c dirname.c xmalloc.c error.c
-  sed -n '/^BEGIN-DATA$/,/^END-DATA$/p' dirname.c|grep -v DATA|./a.out
-
-If it's been built on a DOS or Windows platforms, run another test like
-this (again, expect no output):
-  sed -n '/^BEGIN-DOS-DATA$/,/^END-DOS-DATA$/p' dirname.c|grep -v DATA|./a.out
-
-BEGIN-DATA
-foo//// .
-bar/foo//// bar
-foo/ .
-/ /
-. .
-a .
-END-DATA
-
-BEGIN-DOS-DATA
-c:///// c:/
-c:/ c:/
-c:/. c:/
-c:foo c:.
-c:foo/bar c:foo
-END-DOS-DATA
-
-*/
-
-# define MAX_BUFF_LEN 1024
-# include <stdio.h>
-
-char *program_name;
-
-int
-main (int argc, char *argv[])
-{
-  char buff[MAX_BUFF_LEN + 1];
-
-  program_name = argv[0];
-
-  buff[MAX_BUFF_LEN] = 0;
-  while (fgets (buff, MAX_BUFF_LEN, stdin) && buff[0])
-    {
-      char path[MAX_BUFF_LEN];
-      char expected_result[MAX_BUFF_LEN];
-      char const *result;
-      sscanf (buff, "%s %s", path, expected_result);
-      result = dir_name (path);
-      if (strcmp (result, expected_result))
-	printf ("%s: got %s, expected %s\n", path, result, expected_result);
-    }
-  return 0;
+    dir[length++] = '.';
+  dir[length] = '\0';
+  return dir;
 }
-#endif
diff -up -r dbg/find14/find/gnulib-cvs/gnulib/lib/dirname.h dbg/find6/find/gnulib-cvs/gnulib/lib/dirname.h
