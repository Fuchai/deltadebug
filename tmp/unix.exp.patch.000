--- dbg/find14/find/locate/testsuite/config/unix.exp	2020-01-28 23:47:42.000000000 -0600
+++ dbg/find6/find/locate/testsuite/config/unix.exp	2020-01-28 23:39:42.000000000 -0600
@@ -14,7 +14,7 @@
 # 
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
 # USA.
 
 
@@ -27,10 +27,23 @@
 # We normalise (normalize for those over the water) pathnames 
 # because the updatedb shell script uses "cd", which means that 
 # any relative paths no longer point where we thought they did.
-set env(find) [file normalize "../../find/find"]
+# Because "file normalize" requires tcl 8.4, we have a plan B
+# for normalising the name of a directory, but it is slower.
+
+proc normalize_dir { dir } {
+    if [ catch { file normalize $dir } result ] then {
+	return [ exec /bin/sh -c "cd $dir && /bin/pwd" ]
+    } else {
+	return $result;
+    }
+}
+
+set fulldir [ normalize_dir "../../find" ]
+set env{find} "$fulldir/find"
 
 # use the local help commands for updatedb
-set env(LIBEXECDIR) [file normalize .. ]
+set env(LIBEXECDIR) [ normalize_dir .. ] 
+# use our local version of find, too.
 
 # do not ignore any file systems for this test
 set env(PRUNEFS) ""
@@ -60,6 +73,14 @@ if ![info exists LOCATE] {
     verbose "LOCATE defaulting to $LOCATE" 2
 }
 
+global FIND
+# look for find
+if ![info exists FIND] {
+    set FIND [findfile $base_dir/../../find/find $base_dir/../../find/find [transform find]]
+    verbose "FIND defaulting to $FIND" 2
+}
+set env(find) "$FIND"
+
 global LOCATEFLAGS
 if ![info exists LOCATEFLAGS] then {
     set LOCATEFLAGS ""
@@ -150,11 +171,24 @@ proc locate_textonly { passfail id intex
 }
 
 
+# Do a test in which we expect an input text file to be preserved unchanged.
+proc locate_roundtrip { id intext } {
+    if ![regexp "\n$" $intext] {
+	# We like the items to be terminated by newlines.
+	error "The input text is not terminated by newline"
+    }
+
+    locate_textonly p $id $intext "-r ." $intext
+}
+
+
 
 # Run locate and leave the output in $comp_output.
 # Called by individual test scripts.
 proc locate_start { passfail updatedb_options locate_options
-		    {updatedb_infile ""} {locate_infile ""}} {
+		    {updatedb_infile ""} {locate_infile ""}
+		    { between_hook "" }
+		} {
     global verbose
     global LOCATE
     global LOCATEFLAGS
@@ -196,13 +230,29 @@ proc locate_start { passfail updatedb_op
     if $verbose>1 then {
 	send_user "Spawning \"$updatedb_cmd\"\n"
     }
+    catch "exec $updatedb_cmd" comp_output
+
+    if {$comp_output != ""} then {
+	send_log "$comp_output\n"
+	if $verbose>1 then {
+	    send_user "$comp_output\n"
+	}
+	# If fail_good is set, that refers to the exit status of locate, not updatedb...
+	fail "$testname, $comp_output"
+	return
+    } else {
+	send_log "updatedb: OK.\n"
+    }
+
+
+    eval $between_hook
+    
     set locate_cmd "$LOCATE $LOCATEFLAGS $locate_options < $locate_infile > locate.out"
     send_log "$locate_cmd\n"
     if $verbose>1 then {
 	send_user "Spawning \"$locate_cmd\"\n"
     }
 
-    catch "exec $updatedb_cmd" comp_output
     catch "exec $locate_cmd" comp_output
     if {$comp_output != ""} then {
 	send_log "$comp_output\n"
Only in dbg/find6/find/locate/testsuite/locate.gnu: bigprefix1.exp
Only in dbg/find6/find/locate/testsuite/locate.gnu: exceedshort.exp
Only in dbg/find6/find/locate/testsuite/locate.gnu: exists1.exp
Only in dbg/find6/find/locate/testsuite/locate.gnu: exists1.xo
Only in dbg/find6/find/locate/testsuite/locate.gnu: exists2.exp
Only in dbg/find6/find/locate/testsuite/locate.gnu: exists2.xo
Only in dbg/find6/find/locate/testsuite/locate.gnu: exists3.exp
Only in dbg/find6/find/locate/testsuite/locate.gnu: exists3.xo
diff -up -r dbg/find14/find/locate/testsuite/locate.gnu/ignore_case2.exp dbg/find6/find/locate/testsuite/locate.gnu/ignore_case2.exp
