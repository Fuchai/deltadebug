--- dbg/find14/find/gnulib/lib/strtol.c	2020-01-28 23:47:42.000000000 -0600
+++ dbg/find6/find/gnulib/lib/strtol.c	2020-01-28 23:39:42.000000000 -0600
@@ -1,6 +1,7 @@
 /* Convert string representation of a number into an integer value.
 
-   Copyright (C) 1991, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2003
+   Copyright (C) 1991, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2003, 2005,
+   2006, 2007
    Free Software Foundation, Inc.
 
    NOTE: The canonical source of this file is maintained with the GNU C
@@ -18,21 +19,16 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software Foundation,
-   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
-
-#if HAVE_CONFIG_H
-# include <config.h>
-#endif
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
 
 #ifdef _LIBC
 # define USE_NUMBER_GROUPING
+#else
+# include <config.h>
 #endif
 
 #include <ctype.h>
 #include <errno.h>
-#ifndef errno
-extern int errno;
-#endif
 #ifndef __set_errno
 # define __set_errno(Val) errno = (Val)
 #endif
@@ -124,19 +120,34 @@ extern int errno;
 # define STRTOL_LONG_MAX LONG_LONG_MAX
 # define STRTOL_ULONG_MAX ULONG_LONG_MAX
 
-/* The extra casts work around common compiler bugs,
-   e.g. Cray C 5.0.3.0 when t == time_t.  */
-# ifndef TYPE_SIGNED
-#  define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
-# endif
-# ifndef TYPE_MINIMUM
-#  define TYPE_MINIMUM(t) ((t) (TYPE_SIGNED (t) \
-				? ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1) \
-				: (t) 0))
-# endif
-# ifndef TYPE_MAXIMUM
-#  define TYPE_MAXIMUM(t) ((t) (~ (t) 0 - TYPE_MINIMUM (t)))
-# endif
+/* The extra casts in the following macros work around compiler bugs,
+   e.g., in Cray C 5.0.3.0.  */
+
+/* True if negative values of the signed integer type T use two's
+   complement, ones' complement, or signed magnitude representation,
+   respectively.  Much GNU code assumes two's complement, but some
+   people like to be portable to all possible C hosts.  */
+# define TYPE_TWOS_COMPLEMENT(t) ((t) ~ (t) 0 == (t) -1)
+# define TYPE_ONES_COMPLEMENT(t) ((t) ~ (t) 0 == 0)
+# define TYPE_SIGNED_MAGNITUDE(t) ((t) ~ (t) 0 < (t) -1)
+
+/* True if the arithmetic type T is signed.  */
+# define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
+
+/* The maximum and minimum values for the integer type T.  These
+   macros have undefined behavior if T is signed and has padding bits.
+   If this is a problem for you, please let us know how to fix it for
+   your host.  */
+# define TYPE_MINIMUM(t) \
+   ((t) (! TYPE_SIGNED (t) \
+	 ? (t) 0 \
+	 : TYPE_SIGNED_MAGNITUDE (t) \
+	 ? ~ (t) 0 \
+	 : ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1)))
+# define TYPE_MAXIMUM(t) \
+   ((t) (! TYPE_SIGNED (t) \
+	 ? (t) -1 \
+	 : ~ (~ (t) 0 << (sizeof (t) * CHAR_BIT - 1))))
 
 # ifndef ULONG_LONG_MAX
 #  define ULONG_LONG_MAX TYPE_MAXIMUM (unsigned long long)
@@ -177,9 +188,7 @@ extern int errno;
 # define LOCALE_PARAM_PROTO
 #endif
 
-#if defined _LIBC || defined HAVE_WCHAR_H
-# include <wchar.h>
-#endif
+#include <wchar.h>
 
 #ifdef USE_WIDE_CHAR
 # include <wctype.h>
@@ -196,11 +205,6 @@ extern int errno;
 #  define TOUPPER(Ch) towupper (Ch)
 # endif
 #else
-# if defined STDC_HEADERS || (!defined isascii && !defined HAVE_ISASCII)
-#  define IN_CTYPE_DOMAIN(c) 1
-# else
-#  define IN_CTYPE_DOMAIN(c) isascii(c)
-# endif
 # define L_(Ch) Ch
 # define UCHAR_TYPE unsigned char
 # define STRING_TYPE char
@@ -209,9 +213,9 @@ extern int errno;
 #  define ISALPHA(Ch) __isalpha_l ((Ch), loc)
 #  define TOUPPER(Ch) __toupper_l ((Ch), loc)
 # else
-#  define ISSPACE(Ch) (IN_CTYPE_DOMAIN (Ch) && isspace (Ch))
-#  define ISALPHA(Ch) (IN_CTYPE_DOMAIN (Ch) && isalpha (Ch))
-#  define TOUPPER(Ch) (IN_CTYPE_DOMAIN (Ch) ? toupper (Ch) : (Ch))
+#  define ISSPACE(Ch) isspace (Ch)
+#  define ISALPHA(Ch) isalpha (Ch)
+#  define TOUPPER(Ch) toupper (Ch)
 # endif
 #endif
 
diff -up -r dbg/find14/find/gnulib/lib/strtoll.c dbg/find6/find/gnulib/lib/strtoll.c
