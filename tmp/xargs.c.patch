--- dbg/find14/find/xargs/xargs.c	2020-01-28 23:47:42.000000000 -0600
+++ dbg/find6/find/xargs/xargs.c	2020-01-28 23:39:42.000000000 -0600
@@ -1,5 +1,5 @@
 /* xargs -- build and execute command lines from standard input
-   Copyright (C) 1990, 91, 92, 93, 94, 2000, 2003, 2005 Free Software Foundation, Inc.
+   Copyright (C) 1990, 91, 92, 93, 94, 2000, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -13,12 +13,16 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
    USA.
 */
 
 /* Written by Mike Rendell <michael@cs.mun.ca>
-   and David MacKenzie <djm@gnu.org>.  */
+   and David MacKenzie <djm@gnu.org>.  
+   Modifications by 
+   	James Youngman
+	Dmitry V. Levin
+*/
 
 #include <config.h>
 
@@ -80,9 +84,10 @@
 #define LONG_MAX (~(1 << (sizeof (long) * 8 - 1)))
 #endif
 
-#ifdef HAVE_UNISTD_H
+/* The presence of unistd.h is assumed by gnulib these days, so we 
+ * might as well assume it too. 
+ */
 #include <unistd.h>
-#endif
 
 #include <signal.h>
 
@@ -92,11 +97,6 @@
 
 #include "wait.h"
 
-/* States for read_line. */
-#define NORM 0
-#define SPACE 1
-#define QUOTE 2
-#define BACKSLASH 3
 
 #ifdef STDC_HEADERS
 #include <stdlib.h>
@@ -128,8 +128,6 @@ extern int errno;
 /* Return nonzero if S is the EOF string.  */
 #define EOF_STR(s) (eof_str && *eof_str == *s && !strcmp (eof_str, s))
 
-extern char **environ;
-
 /* Do multibyte processing if multibyte characters are supported,
    unless multibyte sequences are search safe.  Multibyte sequences
    are search safe if searching for a substring using the byte
@@ -165,6 +163,7 @@ typedef int boolean;
 
 #include <xalloc.h>
 #include "closeout.h"
+#include "gnulib-version.h"
 
 void error PARAMS ((int status, int errnum, char *message,...));
 
@@ -186,19 +185,10 @@ static int lineno = 0;
 static struct buildcmd_state bc_state;
 static struct buildcmd_control bc_ctl;
 
-
-#if 0
-/* If nonzero, then instead of putting the args from stdin at
-   the end of the command argument list, they are each stuck into the
-   initial args, replacing each occurrence of the `replace_pat' in the
-   initial args.  */
-static char *replace_pat = NULL;
+/* Did we already complain about NUL characters in the input? */
+static int nullwarning_given = 0;
 
 
-/* The length of `replace_pat'.  */
-static size_t rplen = 0;
-#endif
-
 /* If nonzero, when this string is read on stdin it is treated as
    end of file.
    IEEE Std 1003.1, 2004 Edition allows this to be NULL.
@@ -206,40 +196,6 @@ static size_t rplen = 0;
 */
 static char *eof_str = NULL;
 
-#if 0
-/* If nonzero, the maximum number of nonblank lines from stdin to use
-   per command line.  */
-static long lines_per_exec = 0;
-
-/* The maximum number of arguments to use per command line.  */
-static long args_per_exec = 1024;
-
-/* If true, exit if lines_per_exec or args_per_exec is exceeded.  */
-static boolean exit_if_size_exceeded = false;
-/* The maximum number of characters that can be used per command line.  */
-static long arg_max;
-/* Storage for elements of `cmd_argv'.  */
-static char *argbuf;
-#endif
-
-#if 0
-/* The list of args being built.  */
-static char **cmd_argv = NULL;
-
-/* Number of elements allocated for `cmd_argv'.  */
-static int cmd_argv_alloc = 0;
-#endif
-
-#if 0
-/* Number of valid elements in `cmd_argv'.  */
-static int cmd_argc = 0;
-/* Number of chars being used in `cmd_argv'.  */
-static int cmd_argv_chars = 0;
-
-/* Number of initial arguments given on the command line.  */
-static int initial_argc = 0;
-#endif
-
 /* Number of chars in the initial args.  */
 /* static int initial_argv_chars = 0; */
 
@@ -264,7 +220,9 @@ static int pids_alloc = 0;
 
 /* Exit status; nonzero if any child process exited with a
    status of 1-125.  */
-static int child_error = 0;
+static volatile int child_error = 0;
+
+static volatile int original_exit_value;
 
 /* If true, print each command on stderr before executing it.  */
 static boolean print_command = false; /* Option -t */
@@ -273,10 +231,17 @@ static boolean print_command = false; /*
    execute the command if the user responds affirmatively.  */
 static boolean query_before_executing = false;
 
+/* The delimiter for input arguments.   This is only consulted if the 
+ * -0 or -d option had been given.
+ */
+static char input_delimiter = '\0';
+
+
 static struct option const longopts[] =
 {
   {"null", no_argument, NULL, '0'},
   {"arg-file", required_argument, NULL, 'a'},
+  {"delimiter", required_argument, NULL, 'd'},
   {"eof", optional_argument, NULL, 'e'},
   {"replace", optional_argument, NULL, 'I'},
   {"max-lines", optional_argument, NULL, 'l'},
@@ -295,46 +260,140 @@ static struct option const longopts[] =
 
 static int read_line PARAMS ((void));
 static int read_string PARAMS ((void));
-#if 0
-static char *mbstrstr PARAMS ((const char *haystack, const char *needle));
-static void do_insert PARAMS ((char *arg, size_t arglen, size_t lblen));
-static void push_arg PARAMS ((char *arg, size_t len));
-#endif
 static boolean print_args PARAMS ((boolean ask));
 /* static void do_exec PARAMS ((void)); */
 static int xargs_do_exec (const struct buildcmd_control *cl, struct buildcmd_state *state);
+static void exec_if_possible PARAMS ((void));
 static void add_proc PARAMS ((pid_t pid));
 static void wait_for_proc PARAMS ((boolean all));
+static void wait_for_proc_all PARAMS ((void));
 static long parse_num PARAMS ((char *str, int option, long min, long max, int fatal));
-static long env_size PARAMS ((char **envp));
 static void usage PARAMS ((FILE * stream));
 
 
 
-static long
-get_line_max(void)
+static char 
+get_char_oct_or_hex_escape(const char *s)
 {
-  long val;
-#ifdef _SC_LINE_MAX  
-  val = sysconf(_SC_LINE_MAX);
-#else
-  val = -1;
-#endif
-  
-  if (val > 0)
-    return val;
+  const char * p;
+  int base = 8;
+  unsigned long val;
+  char *endp;
 
-  /* either _SC_LINE_MAX was not available or 
-   * there is no particular limit.
+  assert('\\' == s[0]);
+  
+  if ('x' == s[1])
+    {
+      /* hex */
+      p = s+2;
+      base = 16;
+    }
+  else if (isdigit(s[1]))
+    {
+      /* octal */
+      p = s+1;
+      base = 8;
+    }
+  else
+    {
+      p = NULL;			/* Silence compiler warning. */
+      error(1, 0,
+	    _("Invalid escape sequence %s in input delimiter specification."),
+	    s);
+    }
+  errno = 0;
+  endp = (char*)p;
+  val = strtoul(p, &endp, base);
+  
+  /* This if condition is carefully constructed to do 
+   * the right thing if UCHAR_MAX has the same 
+   * value as ULONG_MAX.   IF UCHAR_MAX==ULONG_MAX,
+   * then val can never be greater than UCHAR_MAX.
    */
-#ifdef LINE_MAX
-  val = LINE_MAX;
-#endif
+  if ((ULONG_MAX == val && ERANGE == errno)
+      || (val > UCHAR_MAX))
+    {
+      if (16 == base)
+	{
+	  error(1, 0,
+		_("Invalid escape sequence %s in input delimiter specification; character values must not exceed %lx."),
+		s, (unsigned long)UCHAR_MAX);
+	}
+      else
+	{
+	  error(1, 0,
+		_("Invalid escape sequence %s in input delimiter specification; character values must not exceed %lo."),
+		s, (unsigned long)UCHAR_MAX);
+	}
+    }
+  
+  /* check for trailing garbage */
+  if (0 != *endp)
+    {
+      error(1, 0,
+	    _("Invalid escape sequence %s in input delimiter specification; trailing characters %s not recognised."),
+	    s, endp);
+    }
+  
+  return (char) val;
+}
 
-  if (val > 0)
-    return val;
 
-  return 2048L;			/* a reasonable guess. */
+static char 
+get_input_delimiter(const char *s)
+{
+  if (1 == strlen(s))
+    {
+      return s[0];
+    }
+  else
+    {
+      if ('\\' == s[0])
+	{
+	  /* an escape code */
+	  switch (s[1])
+	    {
+	    case 'a':
+	      return '\a';
+	    case 'b':
+	      return '\b';
+	    case 'f':
+	      return '\f';
+	    case 'n':
+	      return '\n';
+	    case 'r':
+	      return '\r';
+	    case 't':
+	      return'\t';
+	    case 'v':
+	      return '\v';
+	    case '\\':
+	      return '\\';
+	    default:
+	      return get_char_oct_or_hex_escape(s);
+	    }
+	}
+      else
+	{
+	  error(1, 0,
+		_("Invalid input delimiter specification %s: the delimiter must be either a single character or an escape sequence starting with \\."),
+		s);
+	  /*NOTREACHED*/
+	  return 0;
+	}
+    }
+}
+
+static void 
+noop (void)
+{
+  /* does nothing. */
+}
+
+static void 
+fail_due_to_env_size (void)
+{
+  error (1, 0, _("environment is too large for exec"));
 }
 
 
@@ -345,67 +404,70 @@ main (int argc, char **argv)
   int show_limits = 0;			/* --show-limits */
   int always_run_command = 1;
   char *input_file = "-"; /* "-" is stdin */
-  long posix_arg_size_max;
-  long posix_arg_size_min;
-  long arg_size;
-  long size_of_environment = env_size(environ);
   char *default_cmd = "/bin/echo";
   int (*read_args) PARAMS ((void)) = read_line;
-
+  void (*act_on_init_result)(void) = noop;
+  enum BC_INIT_STATUS bcstatus;
+  
   program_name = argv[0];
-
+  original_exit_value = 0;
+  
 #ifdef HAVE_SETLOCALE
   setlocale (LC_ALL, "");
 #endif
   bindtextdomain (PACKAGE, LOCALEDIR);
   textdomain (PACKAGE);
   atexit (close_stdout);
+  atexit (wait_for_proc_all);
 
-  /* IEE Std 1003.1, 2003 specifies that the combined argument and 
-   * environment list shall not exceed {ARG_MAX}-2048 bytes.  It also 
-   * specifies that it shall be at least LINE_MAX.
-   */
-  posix_arg_size_min = get_line_max();
-  posix_arg_size_max = bc_get_arg_max();
-  posix_arg_size_max -= 2048; /* POSIX.2 requires subtracting 2048.  */
-
-  bc_init_controlinfo(&bc_ctl);
-  assert(bc_ctl.arg_max == posix_arg_size_max);
-
-  bc_ctl.exec_callback = xargs_do_exec;
-
+  bcstatus = bc_init_controlinfo(&bc_ctl);
   
-  /* Start with a reasonable default size, though this can be
-   * adjusted via the -s option.
+  /* The bc_init_controlinfo call may have determined that the 
+   * environment is too big.  In that case, we will fail with 
+   * an error message after processing the command-line options,
+   * as "xargs --help" should still work even if the environment is 
+   * too big.
+   *
+   * Some of the argument processing depends on the contents of 
+   * bc_ctl, which will be in an undefined state if bc_init_controlinfo()
+   * failed.
    */
-  arg_size = (128 * 1024) + size_of_environment;
-
-  /* Take the size of the environment into account.  */
-  if (size_of_environment > posix_arg_size_max)
+  if (BC_INIT_ENV_TOO_BIG == bcstatus)
     {
-      error (1, 0, _("environment is too large for exec"));
+      act_on_init_result = fail_due_to_env_size;
     }
   else
     {
-      bc_ctl.arg_max = posix_arg_size_max - size_of_environment;
+      /* IEEE Std 1003.1, 2003 specifies that the combined argument and 
+       * environment list shall not exceed {ARG_MAX}-2048 bytes.  It also 
+       * specifies that it shall be at least LINE_MAX.
+       */
+#if defined(ARG_MAX)
+      assert(bc_ctl.arg_max <= (ARG_MAX-2048));
+#endif
+      assert(bc_ctl.arg_max >= LINE_MAX);
+      
+      bc_ctl.exec_callback = xargs_do_exec;
+      
+      /* Start with a reasonable default size, though this can be
+       * adjusted via the -s option.
+       */
+      bc_use_sensible_arg_max(&bc_ctl);
     }
-
-  /* Check against the upper and lower limits. */  
-  if (arg_size > bc_ctl.arg_max)
-    arg_size = bc_ctl.arg_max;
-  if (arg_size < posix_arg_size_min)
-    arg_size = posix_arg_size_min;
-  
   
-
-  
-  while ((optc = getopt_long (argc, argv, "+0a:E:e::i::I:l::L:n:prs:txP:",
+  while ((optc = getopt_long (argc, argv, "+0a:E:e::i::I:l::L:n:prs:txP:d:",
 			      longopts, (int *) 0)) != -1)
     {
       switch (optc)
 	{
 	case '0':
 	  read_args = read_string;
+	  input_delimiter = '\0';
+	  break;
+
+	case 'd':
+	  read_args = read_string;
+	  input_delimiter = get_input_delimiter(optarg);
 	  break;
 
 	case 'E':		/* POSIX */
@@ -432,6 +494,12 @@ main (int argc, char **argv)
 	  break;
 
 	case 'L':		/* POSIX */
+	  bc_ctl.lines_per_exec = parse_num (optarg, 'L', 1L, -1L, 1);
+	  /* -L excludes -i -n.  */
+	  bc_ctl.args_per_exec = 0;
+	  bc_ctl.replace_pat = NULL;
+	  break;
+
 	case 'l':		/* deprecated */
 	  if (optarg)
 	    bc_ctl.lines_per_exec = parse_num (optarg, 'l', 1L, -1L, 1);
@@ -458,12 +526,21 @@ main (int argc, char **argv)
 	   * cannot support - in that case, the relevant limit is used.
 	   */
 	case 's':
-	  arg_size = parse_num (optarg, 's', 1L, posix_arg_size_max, 0);
-	  if (arg_size > posix_arg_size_max)
-	    {
-	      error (0, 0, "warning: value %ld for -s option is too large, using %ld instead", arg_size, posix_arg_size_max);
-	      arg_size = posix_arg_size_max;
-	    }
+	  {
+	    size_t arg_size;
+	    act_on_init_result();
+	    arg_size = parse_num (optarg, 's', 1L,
+				  bc_ctl.posix_arg_size_max, 0);
+	    if (arg_size > bc_ctl.posix_arg_size_max)
+	      {
+		error (0, 0,
+		       _("warning: value %ld for -s option is too large, "
+			 "using %ld instead"),
+		       arg_size, bc_ctl.posix_arg_size_max);
+		arg_size = bc_ctl.posix_arg_size_max;
+	      }
+	    bc_ctl.arg_max = arg_size;
+	  }
 	  break;
 
 	case 'S':
@@ -497,6 +574,7 @@ main (int argc, char **argv)
 
 	case 'v':
 	  printf (_("GNU xargs version %s\n"), version_string);
+	  printf (_("Built using GNU gnulib version %s\n"), gnulib_version);
 	  return 0;
 
 	default:
@@ -505,6 +583,16 @@ main (int argc, char **argv)
 	}
     }
 
+  /* If we had deferred failing due to problems in bc_init_controlinfo(),
+   * do it now.
+   *
+   * We issue this error message after processing command line 
+   * arguments so that it is possible to use "xargs --help" even if
+   * the environment is too large. 
+   */
+  act_on_init_result();
+  assert(BC_INIT_OK == bcstatus);
+
   if (0 == strcmp (input_file, "-"))
     {
       input_stream = stdin;
@@ -531,38 +619,58 @@ main (int argc, char **argv)
       argv = &default_cmd;
     }
 
-  /* Taking into account the size of the environment, 
-   * figure out how large a buffer we need to
-   * hold all the arguments.  We cannot use ARG_MAX 
-   * directly since that may be arbitrarily large.
-   * This is from a patch by Bob Prolux, <bob@proulx.com>.
+  /* We want to be able to print size_t values as unsigned long, so if
+   * the cast isn't value-preserving, we have a problem.  This isn't a
+   * problem in C89, because size_t was known to be no wider than
+   * unsigned long.  In C99 this is no longer the case, but there are
+   * special C99 ways to print such values.  Unfortunately this
+   * program tries to work on both C89 and C99 systems.
    */
-  if (bc_ctl.arg_max > arg_size)
-    {
-      if (show_limits)
-	{
-	  fprintf(stderr,
-		  _("Reducing arg_max (%ld) to arg_size (%ld)\n"),
-		  bc_ctl.arg_max, arg_size);
-	}
-      bc_ctl.arg_max = arg_size;
-    }
-
+#if defined(SIZE_MAX)
+# if SIZE_MAX > ULONG_MAX
+# error "I'm not sure how to print size_t values on your system"
+# endif
+#else
+  /* Without SIZE_MAX (i.e. limits.h) this is probably 
+   * close to the best we can do.
+   */
+  assert(sizeof(size_t) <= sizeof(unsigned long));
+#endif
+  
   if (show_limits)
     {
       fprintf(stderr,
-	      _("Your environment variables take up %ld bytes\n"),
-	      size_of_environment);
+	      _("Your environment variables take up %lu bytes\n"),
+	      (unsigned long)bc_size_of_environment());
       fprintf(stderr,
-	      _("POSIX lower and upper limits on argument length: %ld, %ld\n"),
-	      posix_arg_size_min,
-	      posix_arg_size_max);
+	      _("POSIX lower and upper limits on argument length: %lu, %lu\n"),
+	      (unsigned long)bc_ctl.posix_arg_size_min,
+	      (unsigned long)bc_ctl.posix_arg_size_max);
       fprintf(stderr,
 	      _("Maximum length of command we could actually use: %ld\n"),
-	      (posix_arg_size_max - size_of_environment));
+	      (unsigned long)(bc_ctl.posix_arg_size_max -
+			      bc_size_of_environment()));
       fprintf(stderr,
-	      _("Size of command buffer we are actually using: %ld\n"),
-	      arg_size);
+	      _("Size of command buffer we are actually using: %lu\n"),
+	      (unsigned long)bc_ctl.arg_max);
+      
+      if (isatty(STDIN_FILENO))
+	{
+	  fprintf(stderr,
+		  _("\n"
+		    "Execution of xargs will continue now, and it will "
+		    "try to read its input and run commands; if this is "
+		    "not what you wanted to happen, please type the "
+		    "end-of-file keystroke.\n"));
+	  if (always_run_command)
+	    {
+	      fprintf(stderr,
+		      _("Warning: %s will be run at least once.  "
+			"If you do not want that to happen, then press "
+			"the interrupt keystroke.\n"),
+		      argv[optind]);
+	    }
+	}
     }
   
   linebuf = (char *) xmalloc (bc_ctl.arg_max + 1);
@@ -628,64 +736,10 @@ main (int argc, char **argv)
 	}
     }
 
-  wait_for_proc (true);
+  original_exit_value = child_error;
   return child_error;
 }
 
-#if 0
-static int
-append_char_to_buf(char **pbuf, char **pend, char **pp, int c)
-{
-  char *end_of_buffer = *pend;
-  char *start_of_buffer = *pbuf;
-  char *p = *pp;
-  if (p >= end_of_buffer)
-    {
-      if (bc_ctl.replace_pat)
-	{
-	  size_t len = end_of_buffer - start_of_buffer;
-	  size_t offset = p - start_of_buffer;
-	  len *= 2;
-	  start_of_buffer = xrealloc(start_of_buffer, len*2);
-	  if (NULL != start_of_buffer)
-	    {
-	      end_of_buffer = start_of_buffer + len;
-	      p = start_of_buffer + offset;
-	      *p++ = c;
-
-	      /* Update the caller's idea of where the buffer is. */
-	      *pbuf = start_of_buffer;
-	      *pend = end_of_buffer;
-	      *pp = p;
-	      
-	      return 0;
-	    }
-	  else
-	    {
-	      /* Failed to reallocate. */
-	      return -1;
-	    }
-	}
-      else
-	{
-	  /* I suspect that this can never happen now, because append_char_to_buf()
-	   * should only be called when replace_pat is true.
-	   */
-	  error (1, 0, _("argument line too long"));
-	  /*NOTREACHED*/
-	  return -1;
-	}
-    }
-  else
-    {
-      /* Enough space remains. */
-      *p++ = c;
-      *pp = p;
-      return 0;
-    }
-}
-#endif
-
 
 /* Read a line of arguments from the input and add them to the list of
    arguments to pass to the command.  Ignore blank lines and initial blanks.
@@ -697,24 +751,34 @@ append_char_to_buf(char **pbuf, char **p
 static int
 read_line (void)
 {
+/* States for read_line. */
+  enum read_line_state 
+    {
+      NORM = 0,
+      SPACE = 1,
+      QUOTE = 2,
+      BACKSLASH = 3
+    };
   static boolean eof = false;
   /* Start out in mode SPACE to always strip leading spaces (even with -i).  */
-  int state = SPACE;		/* The type of character we last read.  */
+  enum read_line_state state = SPACE; /* The type of character we last read.  */
   int prevc;			/* The previous value of c.  */
   int quotc = 0;		/* The last quote character read.  */
   int c = EOF;
   boolean first = true;		/* true if reading first arg on line.  */
+  boolean seen_arg = false;      /* true if we have seen any arg (or part of one) yet */
   int len;
   char *p = linebuf;
   /* Including the NUL, the args must not grow past this point.  */
   char *endbuf = linebuf + bc_ctl.arg_max - bc_state.cmd_initial_argv_chars - 1;
-
+  
   if (eof)
     return -1;
   while (1)
     {
       prevc = c;
       c = getc (input_stream);
+      
       if (c == EOF)
 	{
 	  /* COMPAT: SYSV seems to ignore stuff on a line that
@@ -724,7 +788,12 @@ read_line (void)
 	    return -1;
 	  *p++ = '\0';
 	  len = p - linebuf;
-	  /* FIXME we don't check for unterminated quotes here.  */
+	  if (state == QUOTE)
+	    {
+	      exec_if_possible ();
+	      error (1, 0, _("unmatched %s quote; by default quotes are special to xargs unless you use the -0 option"),
+		     quotc == '"' ? _("double") : _("single"));
+	    }
 	  if (first && EOF_STR (linebuf))
 	    return -1;
 	  if (!bc_ctl.replace_pat)
@@ -749,9 +818,16 @@ read_line (void)
 		lineno++;	/* For -l.  */
 	      if (p == linebuf)
 		{
-		  /* Blank line.  */
-		  state = SPACE;
-		  continue;
+		  if (seen_arg)
+		    {
+		      /* An empty argument, add it to the list as normal. */
+		    }
+		  else
+		    {
+		      /* Blank line.  */
+		      state = SPACE;
+		      continue;
+		    }
 		}
 	      *p++ = '\0';
 	      len = p - linebuf;
@@ -767,7 +843,12 @@ read_line (void)
 			     initial_args);
 	      return len;
 	    }
-	  if (!bc_ctl.replace_pat && ISSPACE (c))
+	  seen_arg = true;
+
+	  /* POSIX: In the POSIX locale, the separators are <SPC> and
+	   * <TAB>, but not <FF> or <VT>. 
+	   */
+	  if (!bc_ctl.replace_pat && ISBLANK (c))
 	    {
 	      *p++ = '\0';
 	      len = p - linebuf;
@@ -801,11 +882,15 @@ read_line (void)
 
 	case QUOTE:
 	  if (c == '\n')
-	    error (1, 0, _("unmatched %s quote; by default quotes are special to xargs unless you use the -0 option"),
-		   quotc == '"' ? _("double") : _("single"));
+	    {
+	      exec_if_possible ();
+	      error (1, 0, _("unmatched %s quote; by default quotes are special to xargs unless you use the -0 option"),
+		     quotc == '"' ? _("double") : _("single"));
+	    }
 	  if (c == quotc)
 	    {
 	      state = NORM;
+	      seen_arg = true; /* Makes a difference for e.g. just '' or "" as the first arg on a line */
 	      continue;
 	    }
 	  break;
@@ -814,9 +899,23 @@ read_line (void)
 	  state = NORM;
 	  break;
 	}
+      
+      if ( (0 == c) && !nullwarning_given )
+	{
+	  /* This is just a warning message.  We only issue it once. */
+	  error (0, 0,
+		 _("warning: a NUL character occurred in the input.  "
+		   "It cannot be passed through in the argument list.  "
+		   "Did you mean to use the --null option?"));
+	  nullwarning_given = 1;
+	}
+
 #if 1
       if (p >= endbuf)
-	error (1, 0, _("argument line too long"));
+        {
+	  exec_if_possible ();
+	  error (1, 0, _("argument line too long"));
+	}
       *p++ = c;
 #else
       append_char_to_buf(&linebuf, &endbuf, &p, c);
@@ -857,7 +956,7 @@ read_string (void)
 			 initial_args);
 	  return len;
 	}
-      if (c == '\0')
+      if (c == input_delimiter)
 	{
 	  lineno++;		/* For -l.  */
 	  *p++ = '\0';
@@ -870,7 +969,10 @@ read_string (void)
 	  return len;
 	}
       if (p >= endbuf)
-	error (1, 0, _("argument line too long"));
+        {
+	  exec_if_possible ();
+	  error (1, 0, _("argument line too long"));
+	}
       *p++ = c;
     }
 }
@@ -946,6 +1048,9 @@ xargs_do_exec (const struct buildcmd_con
 {
   pid_t child;
 
+  (void) ctl;
+  (void) state;
+  
   bc_push_arg (&bc_ctl, &bc_state,
 	       (char *) NULL, 0,
 	       NULL, 0,
@@ -980,6 +1085,17 @@ xargs_do_exec (const struct buildcmd_con
   return 1;			/* Success */
 }
 
+/* Execute the command if possible.  */
+
+static void
+exec_if_possible (void)
+{
+  if (bc_ctl.replace_pat || initial_args ||
+      bc_state.cmd_argc == bc_ctl.initial_argc || bc_ctl.exit_if_size_exceeded)
+    return;
+  xargs_do_exec (&bc_ctl, &bc_state);
+}
+
 /* Add the process with id PID to the list of processes that have
    been executed.  */
 
@@ -1057,6 +1173,35 @@ wait_for_proc (boolean all)
     }
 }
 
+/* Wait for all child processes to finish.  */
+
+static void
+wait_for_proc_all (void)
+{
+  static boolean waiting = false;
+  
+  if (waiting)
+    return;
+
+  waiting = true;
+  wait_for_proc (true);
+  waiting = false;
+  
+  if (original_exit_value != child_error)
+    {
+      /* wait_for_proc() changed the value of child_error().  This
+       * function is registered via atexit(), and so may have been
+       * called from exit().  We now know that the original value
+       * passed to exit() is no longer the exit status we require.
+       * The POSIX standard states that the behaviour if exit() is
+       * called more than once is undefined.  Therefore we now have to
+       * exit with _exit() instead of exit().
+       */
+      _exit(child_error);
+    }
+  
+}
+
 /* Return the value of the number represented in STR.
    OPTION is the command line option to which STR is the argument.
    If the value does not fall within the boundaries MIN and MAX,
@@ -1108,28 +1253,18 @@ parse_num (char *str, int option, long i
   return val;
 }
 
-/* Return how much of ARG_MAX is used by the environment.  */
-
-static long
-env_size (char **envp)
-{
-  long len = 0;
-
-  while (*envp)
-    len += strlen (*envp++) + 1;
-
-  return len;
-}
-
 static void
 usage (FILE *stream)
 {
   fprintf (stream, _("\
-Usage: %s [-0prtx] [-e[eof-str]] [-i[replace-str]] [-l[max-lines]]\n\
-       [-n max-args] [-s max-chars] [-P max-procs] [--null] [--eof[=eof-str]]\n\
-       [--replace[=replace-str]] [--max-lines[=max-lines]] [--interactive]\n\
-       [--max-chars=max-chars] [--verbose] [--exit] [--max-procs=max-procs]\n\
-       [--max-args=max-args] [--no-run-if-empty] [--arg-file=file]\n\
+Usage: %s [-0prtx] [--interactive] [--null] [-d|--delimiter=delim]\n\
+       [-E eof-str] [-e[eof-str]]  [--eof[=eof-str]]\n\
+       [-L max-lines] [-l[max-lines]] [--max-lines[=max-lines]]\n\
+       [-I replace-str] [-i[replace-str]] [--replace[=replace-str]]\n\
+       [-n max-args] [--max-args=max-args]\n\
+       [-s max-chars] [--max-chars=max-chars]\n\
+       [-P max-procs]  [--max-procs=max-procs] [--show-limits]\n\
+       [--verbose] [--exit] [--no-run-if-empty] [--arg-file=file]\n\
        [--version] [--help] [command [initial-arguments]]\n"),
 	   program_name);
   fputs (_("\nReport bugs to <bug-findutils@gnu.org>.\n"), stream);
Binary files dbg/find14/find/xargs/xargs.o and dbg/find6/find/xargs/xargs.o differ
Only in dbg/find6: find.091557f6
Only in dbg/find14: find.ff248a20
Only in dbg/find14: out
diff -up -r dbg/find14/readme.txt dbg/find6/readme.txt
