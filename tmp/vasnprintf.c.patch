--- dbg/find14/find/gnulib-cvs/gnulib/lib/vasnprintf.c	2020-01-28 23:47:42.000000000 -0600
+++ dbg/find6/find/gnulib-cvs/gnulib/lib/vasnprintf.c	2020-01-28 23:39:42.000000000 -0600
@@ -1,5 +1,5 @@
 /* vsprintf with automatic memory allocation.
-   Copyright (C) 1999, 2002-2004 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2002-2007 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -13,7 +13,7 @@
 
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation,
-   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
 
 /* Tell glibc's <stdio.h> to provide a prototype for snprintf().
    This must come before <config.h> because <config.h> may include
@@ -22,9 +22,7 @@
 # define _GNU_SOURCE    1
 #endif
 
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
+#include <config.h>
 #ifndef IN_LIBINTL
 # include <alloca.h>
 #endif
@@ -36,12 +34,16 @@
 # include "vasnprintf.h"
 #endif
 
+#include <locale.h>	/* localeconv() */
 #include <stdio.h>	/* snprintf(), sprintf() */
 #include <stdlib.h>	/* abort(), malloc(), realloc(), free() */
 #include <string.h>	/* memcpy(), strlen() */
 #include <errno.h>	/* errno */
-#include <limits.h>	/* CHAR_BIT, INT_MAX */
+#include <limits.h>	/* CHAR_BIT */
 #include <float.h>	/* DBL_MAX_EXP, LDBL_MAX_EXP */
+#if HAVE_NL_LANGINFO
+# include <langinfo.h>
+#endif
 #if WIDE_CHAR_VERSION
 # include "wprintf-parse.h"
 #else
@@ -51,8 +53,24 @@
 /* Checked size_t computations.  */
 #include "xsize.h"
 
-#ifdef HAVE_WCHAR_T
-# ifdef HAVE_WCSLEN
+#if NEED_PRINTF_DIRECTIVE_A && !defined IN_LIBINTL
+# include "float+.h"
+# include "isnan.h"
+# include "printf-frexp.h"
+# if HAVE_LONG_DOUBLE
+#  include "isnanl-nolibm.h"
+#  include "printf-frexpl.h"
+#  include "fpucw.h"
+# endif
+#endif
+
+/* Some systems, like OSF/1 4.0 and Woe32, don't have EOVERFLOW.  */
+#ifndef EOVERFLOW
+# define EOVERFLOW E2BIG
+#endif
+
+#if HAVE_WCHAR_T
+# if HAVE_WCSLEN
 #  define local_wcslen wcslen
 # else
    /* Solaris 2.5.1 has wcslen() in a separate library libw.so. To avoid
@@ -102,6 +120,37 @@ local_wcslen (const wchar_t *s)
 # else
    /* Unix.  */
 #  define SNPRINTF snprintf
+   /* Here we need to call the native snprintf, not rpl_snprintf.  */
+#  undef snprintf
+# endif
+#endif
+/* Here we need to call the native sprintf, not rpl_sprintf.  */
+#undef sprintf
+
+#if NEED_PRINTF_DIRECTIVE_A && !defined IN_LIBINTL
+/* Determine the decimal-point character according to the current locale.  */
+# ifndef decimal_point_char_defined
+#  define decimal_point_char_defined 1
+static char
+decimal_point_char ()
+{
+  const char *point;
+  /* Determine it in a multithread-safe way.  We know nl_langinfo is
+     multithread-safe on glibc systems, but is not required to be multithread-
+     safe by POSIX.  sprintf(), however, is multithread-safe.  localeconv()
+     is rarely multithread-safe.  */
+#  if HAVE_NL_LANGINFO && __GLIBC__
+  point = nl_langinfo (RADIXCHAR);
+#  elif 1
+  char pointbuf[5];
+  sprintf (pointbuf, "%#.0f", 1.0);
+  point = &pointbuf[1];
+#  else
+  point = localeconv () -> decimal_point;
+#  endif
+  /* The decimal point is always a single byte: either '.' or ','.  */
+  return (point[0] != '\0' ? point[0] : '.');
+}
 # endif
 #endif
 
@@ -250,7 +299,7 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
 		  case TYPE_COUNT_LONGINT_POINTER:
 		    *a.arg[dp->arg_index].a.a_count_longint_pointer = length;
 		    break;
-#ifdef HAVE_LONG_LONG
+#if HAVE_LONG_LONG_INT
 		  case TYPE_COUNT_LONGLONGINT_POINTER:
 		    *a.arg[dp->arg_index].a.a_count_longlongint_pointer = length;
 		    break;
@@ -259,6 +308,479 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
 		    abort ();
 		  }
 	      }
+#if NEED_PRINTF_DIRECTIVE_A && !defined IN_LIBINTL
+	    else if (dp->conversion == 'a' || dp->conversion == 'A')
+	      {
+		arg_type type = a.arg[dp->arg_index].type;
+		int flags = dp->flags;
+		int has_width;
+		size_t width;
+		int has_precision;
+		size_t precision;
+		size_t tmp_length;
+		CHAR_T tmpbuf[700];
+		CHAR_T *tmp;
+		CHAR_T *pad_ptr;
+		CHAR_T *p;
+
+		has_width = 0;
+		width = 0;
+		if (dp->width_start != dp->width_end)
+		  {
+		    if (dp->width_arg_index != ARG_NONE)
+		      {
+			int arg;
+
+			if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
+			  abort ();
+			arg = a.arg[dp->width_arg_index].a.a_int;
+			if (arg < 0)
+			  {
+			    /* "A negative field width is taken as a '-' flag
+			        followed by a positive field width."  */
+			    flags |= FLAG_LEFT;
+			    width = (unsigned int) (-arg);
+			  }
+			else
+			  width = arg;
+		      }
+		    else
+		      {
+			const CHAR_T *digitp = dp->width_start;
+
+			do
+			  width = xsum (xtimes (width, 10), *digitp++ - '0');
+			while (digitp != dp->width_end);
+		      }
+		    has_width = 1;
+		  }
+
+		has_precision = 0;
+		precision = 0;
+		if (dp->precision_start != dp->precision_end)
+		  {
+		    if (dp->precision_arg_index != ARG_NONE)
+		      {
+			int arg;
+
+			if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))
+			  abort ();
+			arg = a.arg[dp->precision_arg_index].a.a_int;
+			/* "A negative precision is taken as if the precision
+			    were omitted."  */
+			if (arg >= 0)
+			  {
+			    precision = arg;
+			    has_precision = 1;
+			  }
+		      }
+		    else
+		      {
+			const CHAR_T *digitp = dp->precision_start + 1;
+
+			precision = 0;
+			while (digitp != dp->precision_end)
+			  precision = xsum (xtimes (precision, 10), *digitp++ - '0');
+			has_precision = 1;
+		      }
+		  }
+
+		/* Allocate a temporary buffer of sufficient size.  */
+# if HAVE_LONG_DOUBLE
+		if (type == TYPE_LONGDOUBLE)
+		  tmp_length =
+		    (unsigned int) ((LDBL_DIG + 1)
+				    * 0.831 /* decimal -> hexadecimal */
+				   )
+		    + 1; /* turn floor into ceil */
+		else
+# endif
+		  tmp_length =
+		    (unsigned int) ((DBL_DIG + 1)
+				    * 0.831 /* decimal -> hexadecimal */
+				   )
+		    + 1; /* turn floor into ceil */
+		if (tmp_length < precision)
+		  tmp_length = precision;
+		/* Account for sign, decimal point etc. */
+		tmp_length = xsum (tmp_length, 12);
+
+		if (tmp_length < width)
+		  tmp_length = width;
+
+		tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */
+
+		if (tmp_length <= sizeof (tmpbuf) / sizeof (CHAR_T))
+		  tmp = tmpbuf;
+		else
+		  {
+		    size_t tmp_memsize = xtimes (tmp_length, sizeof (CHAR_T));
+
+		    if (size_overflow_p (tmp_memsize))
+		      /* Overflow, would lead to out of memory.  */
+		      goto out_of_memory;
+		    tmp = (CHAR_T *) malloc (tmp_memsize);
+		    if (tmp == NULL)
+		      /* Out of memory.  */
+		      goto out_of_memory;
+		  }
+
+		pad_ptr = NULL;
+		p = tmp;
+# if HAVE_LONG_DOUBLE
+		if (type == TYPE_LONGDOUBLE)
+		  {
+		    long double arg = a.arg[dp->arg_index].a.a_longdouble;
+
+		    if (isnanl (arg))
+		      {
+			if (dp->conversion == 'A')
+			  {
+			    *p++ = 'N'; *p++ = 'A'; *p++ = 'N';
+			  }
+			else
+			  {
+			    *p++ = 'n'; *p++ = 'a'; *p++ = 'n';
+			  }
+		      }
+		    else
+		      {
+			int sign = 0;
+			DECL_LONG_DOUBLE_ROUNDING
+
+			BEGIN_LONG_DOUBLE_ROUNDING ();
+
+			if (arg < 0.0L)
+			  {
+			    sign = -1;
+			    arg = -arg;
+			  }
+			else if (arg == 0.0L)
+			  {
+			    /* Distinguish 0.0L and -0.0L.  */
+			    static long double plus_zero = 0.0L;
+			    long double arg_mem = arg;
+			    if (memcmp (&plus_zero, &arg_mem, SIZEOF_LDBL) != 0)
+			      {
+				sign = -1;
+				arg = -arg;
+			      }
+			  }
+
+			if (sign < 0)
+			  *p++ = '-';
+			else if (flags & FLAG_SHOWSIGN)
+			  *p++ = '+';
+			else if (flags & FLAG_SPACE)
+			  *p++ = ' ';
+
+			if (arg > 0.0L && arg + arg == arg)
+			  {
+			    if (dp->conversion == 'A')
+			      {
+				*p++ = 'I'; *p++ = 'N'; *p++ = 'F';
+			      }
+			    else
+			      {
+				*p++ = 'i'; *p++ = 'n'; *p++ = 'f';
+			      }
+			  }
+			else
+			  {
+			    int exponent;
+			    long double mantissa;
+
+			    if (arg > 0.0L)
+			      mantissa = printf_frexpl (arg, &exponent);
+			    else
+			      {
+				exponent = 0;
+				mantissa = 0.0L;
+			      }
+
+			    if (has_precision
+				&& precision < (unsigned int) ((LDBL_DIG + 1) * 0.831) + 1)
+			      {
+				/* Round the mantissa.  */
+				long double tail = mantissa;
+				size_t q;
+
+				for (q = precision; ; q--)
+				  {
+				    int digit = (int) tail;
+				    tail -= digit;
+				    if (q == 0)
+				      {
+					if (digit & 1 ? tail >= 0.5L : tail > 0.5L)
+					  tail = 1 - tail;
+					else
+					  tail = - tail;
+					break;
+				      }
+				    tail *= 16.0L;
+				  }
+				if (tail != 0.0L)
+				  for (q = precision; q > 0; q--)
+				    tail *= 0.0625L;
+				mantissa += tail;
+			      }
+
+			    *p++ = '0';
+			    *p++ = dp->conversion - 'A' + 'X';
+			    pad_ptr = p;
+			    {
+			      int digit;
+
+			      digit = (int) mantissa;
+			      mantissa -= digit;
+			      *p++ = '0' + digit;
+			      if ((flags & FLAG_ALT)
+				  || mantissa > 0.0L || precision > 0)
+				{
+				  *p++ = decimal_point_char ();
+				  /* This loop terminates because we assume
+				     that FLT_RADIX is a power of 2.  */
+				  while (mantissa > 0.0L)
+				    {
+				      mantissa *= 16.0L;
+				      digit = (int) mantissa;
+				      mantissa -= digit;
+				      *p++ = digit
+					     + (digit < 10
+						? '0'
+						: dp->conversion - 10);
+				      if (precision > 0)
+					precision--;
+				    }
+				  while (precision > 0)
+				    {
+				      *p++ = '0';
+				      precision--;
+				    }
+				}
+			      }
+			      *p++ = dp->conversion - 'A' + 'P';
+#  if WIDE_CHAR_VERSION
+			      {
+				static const wchar_t decimal_format[] =
+				  { '%', '+', 'd', '\0' };
+				SNPRINTF (p, 6 + 1, decimal_format, exponent);
+			      }
+#  else
+			      sprintf (p, "%+d", exponent);
+#  endif
+			      while (*p != '\0')
+				p++;
+			  }
+
+			END_LONG_DOUBLE_ROUNDING ();
+		      }
+		  }
+		else
+# endif
+		  {
+		    double arg = a.arg[dp->arg_index].a.a_double;
+
+		    if (isnan (arg))
+		      {
+			if (dp->conversion == 'A')
+			  {
+			    *p++ = 'N'; *p++ = 'A'; *p++ = 'N';
+			  }
+			else
+			  {
+			    *p++ = 'n'; *p++ = 'a'; *p++ = 'n';
+			  }
+		      }
+		    else
+		      {
+			int sign = 0;
+
+			if (arg < 0.0)
+			  {
+			    sign = -1;
+			    arg = -arg;
+			  }
+			else if (arg == 0.0)
+			  {
+			    /* Distinguish 0.0 and -0.0.  */
+			    static double plus_zero = 0.0;
+			    double arg_mem = arg;
+			    if (memcmp (&plus_zero, &arg_mem, SIZEOF_DBL) != 0)
+			      {
+				sign = -1;
+				arg = -arg;
+			      }
+			  }
+
+			if (sign < 0)
+			  *p++ = '-';
+			else if (flags & FLAG_SHOWSIGN)
+			  *p++ = '+';
+			else if (flags & FLAG_SPACE)
+			  *p++ = ' ';
+
+			if (arg > 0.0 && arg + arg == arg)
+			  {
+			    if (dp->conversion == 'A')
+			      {
+				*p++ = 'I'; *p++ = 'N'; *p++ = 'F';
+			      }
+			    else
+			      {
+				*p++ = 'i'; *p++ = 'n'; *p++ = 'f';
+			      }
+			  }
+			else
+			  {
+			    int exponent;
+			    double mantissa;
+
+			    if (arg > 0.0)
+			      mantissa = printf_frexp (arg, &exponent);
+			    else
+			      {
+				exponent = 0;
+				mantissa = 0.0;
+			      }
+
+			    if (has_precision
+				&& precision < (unsigned int) ((DBL_DIG + 1) * 0.831) + 1)
+			      {
+				/* Round the mantissa.  */
+				double tail = mantissa;
+				size_t q;
+
+				for (q = precision; ; q--)
+				  {
+				    int digit = (int) tail;
+				    tail -= digit;
+				    if (q == 0)
+				      {
+					if (digit & 1 ? tail >= 0.5 : tail > 0.5)
+					  tail = 1 - tail;
+					else
+					  tail = - tail;
+					break;
+				      }
+				    tail *= 16.0;
+				  }
+				if (tail != 0.0)
+				  for (q = precision; q > 0; q--)
+				    tail *= 0.0625;
+				mantissa += tail;
+			      }
+
+			    *p++ = '0';
+			    *p++ = dp->conversion - 'A' + 'X';
+			    pad_ptr = p;
+			    {
+			      int digit;
+
+			      digit = (int) mantissa;
+			      mantissa -= digit;
+			      *p++ = '0' + digit;
+			      if ((flags & FLAG_ALT)
+				  || mantissa > 0.0 || precision > 0)
+				{
+				  *p++ = decimal_point_char ();
+				  /* This loop terminates because we assume
+				     that FLT_RADIX is a power of 2.  */
+				  while (mantissa > 0.0)
+				    {
+				      mantissa *= 16.0;
+				      digit = (int) mantissa;
+				      mantissa -= digit;
+				      *p++ = digit
+					     + (digit < 10
+						? '0'
+						: dp->conversion - 10);
+				      if (precision > 0)
+					precision--;
+				    }
+				  while (precision > 0)
+				    {
+				      *p++ = '0';
+				      precision--;
+				    }
+				}
+			      }
+			      *p++ = dp->conversion - 'A' + 'P';
+# if WIDE_CHAR_VERSION
+			      {
+				static const wchar_t decimal_format[] =
+				  { '%', '+', 'd', '\0' };
+				SNPRINTF (p, 6 + 1, decimal_format, exponent);
+			      }
+# else
+			      sprintf (p, "%+d", exponent);
+# endif
+			      while (*p != '\0')
+				p++;
+			  }
+		      }
+		  }
+		/* The generated string now extends from tmp to p, with the
+		   zero padding insertion point being at pad_ptr.  */
+		if (has_width && p - tmp < width)
+		  {
+		    size_t pad = width - (p - tmp);
+		    CHAR_T *end = p + pad;
+
+		    if (flags & FLAG_LEFT)
+		      {
+			/* Pad with spaces on the right.  */
+			for (; pad > 0; pad--)
+			  *p++ = ' ';
+		      }
+		    else if ((flags & FLAG_ZERO) && pad_ptr != NULL)
+		      {
+			/* Pad with zeroes.  */
+			CHAR_T *q = end;
+
+			while (p > pad_ptr)
+			  *--q = *--p;
+			for (; pad > 0; pad--)
+			  *p++ = '0';
+		      }
+		    else
+		      {
+			/* Pad with spaces on the left.  */
+			CHAR_T *q = end;
+
+			while (p > tmp)
+			  *--q = *--p;
+			for (; pad > 0; pad--)
+			  *p++ = ' ';
+		      }
+
+		    p = end;
+		  }
+
+		{
+		  size_t count = p - tmp;
+
+		  if (count >= tmp_length)
+		    /* tmp_length was incorrectly calculated - fix the
+		       code above!  */
+		    abort ();
+
+		  /* Make room for the result.  */
+		  if (count >= allocated - length)
+		    {
+		      size_t n = xsum (length, count);
+
+		      ENSURE_ALLOCATION (n);
+		    }
+
+		  /* Append the result.  */
+		  memcpy (result + length, tmp, count * sizeof (CHAR_T));
+		  if (tmp != tmpbuf)
+		    free (tmp);
+		  length += count;
+		}
+	      }
+#endif
 	    else
 	      {
 		arg_type type = a.arg[dp->arg_index].type;
@@ -324,44 +846,43 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
 		    {
 
 		    case 'd': case 'i': case 'u':
-# ifdef HAVE_LONG_LONG
+# if HAVE_LONG_LONG_INT
 		      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)
 			tmp_length =
 			  (unsigned int) (sizeof (unsigned long long) * CHAR_BIT
 					  * 0.30103 /* binary -> decimal */
-					  * 2 /* estimate for FLAG_GROUP */
 					 )
-			  + 1 /* turn floor into ceil */
-			  + 1; /* account for leading sign */
+			  + 1; /* turn floor into ceil */
 		      else
 # endif
 		      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)
 			tmp_length =
 			  (unsigned int) (sizeof (unsigned long) * CHAR_BIT
 					  * 0.30103 /* binary -> decimal */
-					  * 2 /* estimate for FLAG_GROUP */
 					 )
-			  + 1 /* turn floor into ceil */
-			  + 1; /* account for leading sign */
+			  + 1; /* turn floor into ceil */
 		      else
 			tmp_length =
 			  (unsigned int) (sizeof (unsigned int) * CHAR_BIT
 					  * 0.30103 /* binary -> decimal */
-					  * 2 /* estimate for FLAG_GROUP */
 					 )
-			  + 1 /* turn floor into ceil */
-			  + 1; /* account for leading sign */
+			  + 1; /* turn floor into ceil */
+		      if (tmp_length < precision)
+			tmp_length = precision;
+		      /* Multiply by 2, as an estimate for FLAG_GROUP.  */
+		      tmp_length = xsum (tmp_length, tmp_length);
+		      /* Add 1, to account for a leading sign.  */
+		      tmp_length = xsum (tmp_length, 1);
 		      break;
 
 		    case 'o':
-# ifdef HAVE_LONG_LONG
+# if HAVE_LONG_LONG_INT
 		      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)
 			tmp_length =
 			  (unsigned int) (sizeof (unsigned long long) * CHAR_BIT
 					  * 0.333334 /* binary -> octal */
 					 )
-			  + 1 /* turn floor into ceil */
-			  + 1; /* account for leading sign */
+			  + 1; /* turn floor into ceil */
 		      else
 # endif
 		      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)
@@ -369,26 +890,27 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
 			  (unsigned int) (sizeof (unsigned long) * CHAR_BIT
 					  * 0.333334 /* binary -> octal */
 					 )
-			  + 1 /* turn floor into ceil */
-			  + 1; /* account for leading sign */
+			  + 1; /* turn floor into ceil */
 		      else
 			tmp_length =
 			  (unsigned int) (sizeof (unsigned int) * CHAR_BIT
 					  * 0.333334 /* binary -> octal */
 					 )
-			  + 1 /* turn floor into ceil */
-			  + 1; /* account for leading sign */
+			  + 1; /* turn floor into ceil */
+		      if (tmp_length < precision)
+			tmp_length = precision;
+		      /* Add 1, to account for a leading sign.  */
+		      tmp_length = xsum (tmp_length, 1);
 		      break;
 
 		    case 'x': case 'X':
-# ifdef HAVE_LONG_LONG
+# if HAVE_LONG_LONG_INT
 		      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)
 			tmp_length =
 			  (unsigned int) (sizeof (unsigned long long) * CHAR_BIT
 					  * 0.25 /* binary -> hexadecimal */
 					 )
-			  + 1 /* turn floor into ceil */
-			  + 2; /* account for leading sign or alternate form */
+			  + 1; /* turn floor into ceil */
 		      else
 # endif
 		      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)
@@ -396,19 +918,21 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
 			  (unsigned int) (sizeof (unsigned long) * CHAR_BIT
 					  * 0.25 /* binary -> hexadecimal */
 					 )
-			  + 1 /* turn floor into ceil */
-			  + 2; /* account for leading sign or alternate form */
+			  + 1; /* turn floor into ceil */
 		      else
 			tmp_length =
 			  (unsigned int) (sizeof (unsigned int) * CHAR_BIT
 					  * 0.25 /* binary -> hexadecimal */
 					 )
-			  + 1 /* turn floor into ceil */
-			  + 2; /* account for leading sign or alternate form */
+			  + 1; /* turn floor into ceil */
+		      if (tmp_length < precision)
+			tmp_length = precision;
+		      /* Add 2, to account for a leading sign or alternate form.  */
+		      tmp_length = xsum (tmp_length, 2);
 		      break;
 
 		    case 'f': case 'F':
-# ifdef HAVE_LONG_DOUBLE
+# if HAVE_LONG_DOUBLE
 		      if (type == TYPE_LONGDOUBLE)
 			tmp_length =
 			  (unsigned int) (LDBL_MAX_EXP
@@ -430,14 +954,34 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
 		      break;
 
 		    case 'e': case 'E': case 'g': case 'G':
-		    case 'a': case 'A':
 		      tmp_length =
 			12; /* sign, decimal point, exponent etc. */
 		      tmp_length = xsum (tmp_length, precision);
 		      break;
 
+		    case 'a': case 'A':
+# if HAVE_LONG_DOUBLE
+		      if (type == TYPE_LONGDOUBLE)
+			tmp_length =
+			  (unsigned int) (LDBL_DIG
+					  * 0.831 /* decimal -> hexadecimal */
+					 )
+			  + 1; /* turn floor into ceil */
+		      else
+# endif
+			tmp_length =
+			  (unsigned int) (DBL_DIG
+					  * 0.831 /* decimal -> hexadecimal */
+					 )
+			  + 1; /* turn floor into ceil */
+		      if (tmp_length < precision)
+			tmp_length = precision;
+		      /* Account for sign, decimal point etc. */
+		      tmp_length = xsum (tmp_length, 12);
+		      break;
+
 		    case 'c':
-# if defined HAVE_WINT_T && !WIDE_CHAR_VERSION
+# if HAVE_WINT_T && !WIDE_CHAR_VERSION
 		      if (type == TYPE_WIDE_CHAR)
 			tmp_length = MB_CUR_MAX;
 		      else
@@ -446,7 +990,7 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
 		      break;
 
 		    case 's':
-# ifdef HAVE_WCHAR_T
+# if HAVE_WCHAR_T
 		      if (type == TYPE_WIDE_STRING)
 			{
 			  tmp_length =
@@ -527,7 +1071,7 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
 
 		switch (type)
 		  {
-#ifdef HAVE_LONG_LONG
+#if HAVE_LONG_LONG_INT
 		  case TYPE_LONGLONGINT:
 		  case TYPE_ULONGLONGINT:
 		    *p++ = 'l';
@@ -535,15 +1079,15 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
 #endif
 		  case TYPE_LONGINT:
 		  case TYPE_ULONGINT:
-#ifdef HAVE_WINT_T
+#if HAVE_WINT_T
 		  case TYPE_WIDE_CHAR:
 #endif
-#ifdef HAVE_WCHAR_T
+#if HAVE_WCHAR_T
 		  case TYPE_WIDE_STRING:
 #endif
 		    *p++ = 'l';
 		    break;
-#ifdef HAVE_LONG_DOUBLE
+#if HAVE_LONG_DOUBLE
 		  case TYPE_LONGDOUBLE:
 		    *p++ = 'L';
 		    break;
@@ -593,6 +1137,9 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
 		    retcount = 0;
 
 #if USE_SNPRINTF
+		    /* SNPRINTF can fail if maxlen > INT_MAX.  */
+		    if (maxlen > INT_MAX)
+		      goto overflow;
 # define SNPRINTF_BUF(arg) \
 		    switch (prefix_count)				    \
 		      {							    \
@@ -681,7 +1228,7 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
 			  SNPRINTF_BUF (arg);
 			}
 			break;
-#ifdef HAVE_LONG_LONG
+#if HAVE_LONG_LONG_INT
 		      case TYPE_LONGLONGINT:
 			{
 			  long long int arg = a.arg[dp->arg_index].a.a_longlongint;
@@ -701,7 +1248,7 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
 			  SNPRINTF_BUF (arg);
 			}
 			break;
-#ifdef HAVE_LONG_DOUBLE
+#if HAVE_LONG_DOUBLE
 		      case TYPE_LONGDOUBLE:
 			{
 			  long double arg = a.arg[dp->arg_index].a.a_longdouble;
@@ -715,7 +1262,7 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
 			  SNPRINTF_BUF (arg);
 			}
 			break;
-#ifdef HAVE_WINT_T
+#if HAVE_WINT_T
 		      case TYPE_WIDE_CHAR:
 			{
 			  wint_t arg = a.arg[dp->arg_index].a.a_wide_char;
@@ -729,7 +1276,7 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
 			  SNPRINTF_BUF (arg);
 			}
 			break;
-#ifdef HAVE_WCHAR_T
+#if HAVE_WCHAR_T
 		      case TYPE_WIDE_STRING:
 			{
 			  const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;
@@ -862,16 +1409,18 @@ VASNPRINTF (CHAR_T *resultbuf, size_t *l
       free (buf_malloced);
     CLEANUP ();
     *lengthp = length;
-    if (length > INT_MAX)
-      goto length_overflow;
+    /* Note that we can produce a big string of a length > INT_MAX.  POSIX
+       says that snprintf() fails with errno = EOVERFLOW in this case, but
+       that's only because snprintf() returns an 'int'.  This function does
+       not have this limitation.  */
     return result;
 
-  length_overflow:
-    /* We could produce such a big string, but its length doesn't fit into
-       an 'int'.  POSIX says that snprintf() fails with errno = EOVERFLOW in
-       this case.  */
-    if (result != resultbuf)
+  overflow:
+    if (!(result == resultbuf || result == NULL))
       free (result);
+    if (buf_malloced != NULL)
+      free (buf_malloced);
+    CLEANUP ();
     errno = EOVERFLOW;
     return NULL;
 
diff -up -r dbg/find14/find/gnulib-cvs/gnulib/lib/vasnprintf.h dbg/find6/find/gnulib-cvs/gnulib/lib/vasnprintf.h
