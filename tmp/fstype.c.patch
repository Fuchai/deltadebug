--- dbg/find14/find/find/fstype.c	2020-01-28 23:47:42.000000000 -0600
+++ dbg/find6/find/find/fstype.c	2020-01-28 23:39:42.000000000 -0600
@@ -13,7 +13,7 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
    USA.
 */
 
@@ -34,9 +34,10 @@
 #include <sys/types.h>
 #endif
 
-#ifdef HAVE_UNISTD_H
+/* The presence of unistd.h is assumed by gnulib these days, so we 
+ * might as well assume it too. 
+ */
 #include <unistd.h>
-#endif
 
 #ifdef HAVE_SYS_MNTIO_H
 #ifdef HAVE_FCNTL_H
@@ -80,7 +81,7 @@ extern int errno;
 # define N_(String) String
 #endif
 
-static char *filesystem_type_uncached PARAMS((const struct stat *statp));
+static char *filesystem_type_uncached PARAMS((const struct stat *statp, const char *path));
 
 
 /* Get MNTTYPE_IGNORE if it is available. */
@@ -156,7 +157,7 @@ static int fstype_known = 0;
    Return "unknown" if its filesystem type is unknown.  */
 
 char *
-filesystem_type (const struct stat *statp)
+filesystem_type (const struct stat *statp, const char *path)
 {
   static char *current_fstype = NULL;
   static dev_t current_dev;
@@ -168,7 +169,7 @@ filesystem_type (const struct stat *stat
       free (current_fstype);
     }
   current_dev = statp->st_dev;
-  current_fstype = filesystem_type_uncached (statp);
+  current_fstype = filesystem_type_uncached (statp, path);
   return current_fstype;
 }
 
@@ -179,6 +180,7 @@ set_fstype_devno(struct mount_entry *p)
   
   if (p->me_dev == (dev_t)-1)
     {
+      set_stat_placeholders(&stbuf);
       if (0 == (options.xstat)(p->me_mountdir, &stbuf))
 	{
 	  p->me_dev = stbuf.st_dev;
@@ -192,6 +194,22 @@ set_fstype_devno(struct mount_entry *p)
   return 0;			/* not needed */
 }
 
+static struct mount_entry *
+must_read_fs_list(bool need_fs_type)
+{
+  struct mount_entry *entries = read_file_system_list(need_fs_type);
+  if (NULL == entries)
+    {
+      /* We cannot determine for sure which file we were trying to
+       * use because gnulib has extracted all that stuff away. 
+       * Hence we cannot issue a specific error message here.
+       */
+      error(1, 0, "Cannot read mounted filesystem list");
+    }
+  return entries;
+}
+
+
 
 /* Return a newly allocated string naming the type of filesystem that the
    file PATH, described by STATP, is on.
@@ -199,11 +217,13 @@ set_fstype_devno(struct mount_entry *p)
    Return "unknown" if its filesystem type is unknown.  */
 
 static char *
-filesystem_type_uncached (const struct stat *statp)
+filesystem_type_uncached (const struct stat *statp, const char *path)
 {
   struct mount_entry *entries, *entry;
   char *type;
 
+  (void) path;
+  
 #ifdef AFS
   if (in_afs(path))
     {
@@ -212,7 +232,7 @@ filesystem_type_uncached (const struct s
     }
 #endif 
   
-  entries = read_file_system_list(true);
+  entries = must_read_fs_list(true);
   for (type=NULL, entry=entries; entry; entry=entry->me_next)
     {
 #ifdef MNTTYPE_IGNORE
@@ -221,7 +241,10 @@ filesystem_type_uncached (const struct s
 #endif
       set_fstype_devno(entry);
       if (entry->me_dev == statp->st_dev)
-	type = xstrdup(entry->me_type);
+	{
+	  type = xstrdup(entry->me_type);
+	  break;
+	}
     }
   free_file_system_list(entries);
 
@@ -240,7 +263,7 @@ get_mounted_filesystems (void)
   size_t used = 0u;
   struct mount_entry *entries, *entry;
   
-  entries = read_file_system_list(false);
+  entries = must_read_fs_list(false);
   for (entry=entries; entry; entry=entry->me_next)
     {
       size_t len;
@@ -269,7 +292,13 @@ get_mounted_devices (size_t *n)
   size_t used = 0u;
   struct mount_entry *entries, *entry;
   dev_t *result = NULL;
-  
+
+  /* Use read_file_system_list() rather than must_read_fs_list()
+   * because on some system this is always called at startup,
+   * and find should only exit fatally if it needs to use the 
+   * result of this operation.   If we can't get the fs list 
+   * but we never need the information, there is no need to fail.
+   */
   for (entry = entries = read_file_system_list(false);
        entry;
        entry = entry->me_next)
Binary files dbg/find14/find/find/fstype.o and dbg/find6/find/find/fstype.o differ
Only in dbg/find6/find/find: ftsfind.c
Only in dbg/find6/find/find: ftsfind.o
Only in dbg/find6/find/find: libfindtools.a
diff -up -r dbg/find14/find/find/Makefile dbg/find6/find/find/Makefile
