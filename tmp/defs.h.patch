--- dbg/find14/find/find/defs.h	2020-01-28 23:47:42.000000000 -0600
+++ dbg/find6/find/find/defs.h	2020-01-28 23:39:42.000000000 -0600
@@ -1,5 +1,5 @@
 /* defs.h -- data types and declarations.
-   Copyright (C) 1990, 91, 92, 93, 94, 2000, 2004 Free Software Foundation, Inc.
+   Copyright (C) 1990, 91, 92, 93, 94, 2000, 2004, 2005, 2006 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -13,7 +13,7 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
    USA.
 */
 #ifndef INC_DEFS_H
@@ -45,9 +45,10 @@ extern int errno;
 #include <stdlib.h>
 #endif
 
-#ifdef HAVE_UNISTD_H
+/* The presence of unistd.h is assumed by gnulib these days, so we 
+ * might as well assume it too. 
+ */
 #include <unistd.h>
-#endif
 
 #include <time.h>
 
@@ -63,6 +64,9 @@ extern int errno;
 #endif
 
 #include "regex.h"
+#include "timespec.h"
+#include "buildcmd.h"
+
 
 #ifndef S_IFLNK
 #define lstat stat
@@ -82,9 +86,15 @@ int stat PARAMS((const char *__path, str
 int optionl_stat PARAMS((const char *name, struct stat *p));
 int optionp_stat PARAMS((const char *name, struct stat *p));
 int optionh_stat PARAMS((const char *name, struct stat *p));
+int debug_stat   PARAMS((const char *file, struct stat *bufp));
 
+void set_stat_placeholders PARAMS((struct stat *p));
 int get_statinfo PARAMS((const char *pathname, const char *name, struct stat *p));
 
+#if ! defined HAVE_FCHDIR && ! defined fchdir
+# define fchdir(fd) (-1)
+#endif
+
 
 
 #ifndef S_ISUID
@@ -140,8 +150,11 @@ typedef int boolean;
 #define		false	0
 #endif
 
-/* Pointer to function returning boolean. */
-typedef boolean (*PFB)();
+struct predicate;
+struct options;
+
+/* Pointer to a predicate function. */
+typedef boolean (*PRED_FUNC)(char *pathname, struct stat *stat_buf, struct predicate *pred_ptr);
 
 /* The number of seconds in a day. */
 #define		DAYSECS	    86400
@@ -192,7 +205,7 @@ struct long_val
 struct perm_val
 {
   enum permissions_type kind;
-  mode_t val;
+  mode_t val[2];
 };
 
 /* dir_id is used to support loop detection in find.c and 
@@ -211,36 +224,30 @@ struct size_val
   uintmax_t size;
 };
 
-#define NEW_EXEC 1
-/*
-#undef NEW_EXEC 
-*/
 
-#if !defined(NEW_EXEC)
-struct path_arg
+enum xval 
+  {
+    XVAL_ATIME, XVAL_BIRTHTIME, XVAL_CTIME, XVAL_MTIME, XVAL_TIME
+  };
+
+struct time_val
 {
-  short offset;			/* Offset in `vec' of this arg. */
-  short count;			/* Number of path replacements in this arg. */
-  char *origarg;		/* Arg with "{}" intact. */
+  enum xval            xval; 
+  enum comparison_type kind;
+  struct timespec      ts;
 };
-#endif
-
-#include "buildcmd.h"
 
+    
 struct exec_val
 {
-#if defined(NEW_EXEC)
-  /* new-style */
   boolean multiple;		/* -exec {} \+ denotes multiple argument. */
   struct buildcmd_control ctl;
   struct buildcmd_state   state;
   char **replace_vec;		/* Command arguments (for ";" style) */
   int num_args;
   boolean use_current_dir;      /* If nonzero, don't chdir to start dir */
-#else
-  struct path_arg *paths;	/* Array of args with path replacements. */
-  char **vec;			/* Array of args to pass to program. */
-#endif
+  boolean close_stdin;		/* If true, close stdin in the child. */
+  int dirfd;			/* The directory to do the exec in. */
 };
 
 /* The format string for a -printf or -fprintf is chopped into one or
@@ -249,12 +256,17 @@ struct exec_val
    each \c and `%' conversion is a segment. */
 
 /* Special values for the `kind' field of `struct segment'. */
-#define KIND_PLAIN 0		/* Segment containing just plain text. */
-#define KIND_STOP 1		/* \c -- stop printing and flush output. */
+enum SegmentKind 
+  {
+    KIND_PLAIN=0,		/* Segment containing just plain text. */
+    KIND_STOP=1,		/* \c -- stop printing and flush output. */
+    KIND_FORMAT,		/* Regular format */
+  };
 
 struct segment
 {
-  int kind;			/* Format chars or KIND_{PLAIN,STOP}. */
+  enum SegmentKind segkind;     /* KIND_FORMAT, KIND_PLAIN, KIND_STOP */
+  char format_char[2];		/* Format chars if kind is KIND_FORMAT */
   char *text;			/* Plain text or `%' format string. */
   int text_len;			/* Length of `text'. */
   struct segment *next;		/* Next segment for this predicate. */
@@ -264,12 +276,30 @@ struct format_val
 {
   struct segment *segment;	/* Linked list of segments. */
   FILE *stream;			/* Output stream to print on. */
+  boolean dest_is_tty;		/* True if the destination is a terminal. */
+  struct quoting_options *quote_opts;
 };
 
+/* evaluation cost of a predicate */
+enum EvaluationCost
+{
+  NeedsNothing,
+  NeedsType,
+  NeedsStatInfo,
+  NeedsLinkName,
+  NeedsAccessInfo,
+  NeedsSyncDiskHit,
+  NeedsEventualExec,
+  NeedsImmediateExec,
+  NeedsUserInteraction,
+  NeedsUnknown,
+  NumEvaluationCosts
+};
+    
 struct predicate
 {
   /* Pointer to the function that implements this predicate.  */
-  PFB pred_func;
+  PRED_FUNC pred_func;
 
   /* Only used for debugging, but defined unconditionally so individual
      modules can be compiled with -DDEBUG.  */
@@ -297,6 +327,20 @@ struct predicate
   /* True if this predicate node requires knowledge of the file type. */
   boolean need_type;
 
+  enum EvaluationCost p_cost;
+
+  /* est_success_rate is a number between 0.0 and 1.0 */
+  float est_success_rate;
+  
+  /* True if this predicate should display control characters literally */
+  boolean literal_control_chars;
+
+  /* True if this predicate didn't originate from the user. */
+  boolean artificial;
+
+  /* The raw text of the argument of this predicate. */
+  char *arg_text;
+  
   /* Information needed by the predicate processor.
      Next to each member are listed the predicates that use it. */
   union
@@ -304,21 +348,20 @@ struct predicate
     char *str;			/* fstype [i]lname [i]name [i]path */
     struct re_pattern_buffer *regex; /* regex */
     struct exec_val exec_vec;	/* exec ok */
-    struct long_val info;	/* atime ctime gid inum links mtime
-                                   size uid */
+    struct long_val numinfo;	/* gid inum links  uid */
     struct size_val size;	/* size */
     uid_t uid;			/* user */
     gid_t gid;			/* group */
-    time_t time;		/* newer */
+    struct time_val reftime;	/* newer newerXY anewer cnewer mtime atime ctime mmin amin cmin */
     struct perm_val perm;	/* perm */
     struct dir_id   fileid;	/* samefile */
     mode_t type;		/* type */
-    FILE *stream;		/* fprint fprint0 */
-    struct format_val printf_vec; /* printf fprintf */
+    FILE *stream;		/* ls fls fprint0 */
+    struct format_val printf_vec; /* printf fprintf fprint  */
   } args;
 
   /* The next predicate in the user input sequence,
-     which repesents the order in which the user supplied the
+     which represents the order in which the user supplied the
      predicates on the command line. */
   struct predicate *pred_next;
 
@@ -327,12 +370,14 @@ struct predicate
      processed. */
   struct predicate *pred_left;
   struct predicate *pred_right;
-};
 
-/* find.c. */
-int get_info PARAMS((const char *pathname, const char *name, struct stat *p, struct predicate *pred_ptr));
-int following_links(void);
+  const struct parser_table* parser_entry;
+};
 
+/* find.c, ftsfind.c */
+boolean is_fts_enabled(int *ftsoptions);
+int get_start_dirfd(void);
+int get_current_dirfd(void);
 
 /* find library function declarations.  */
 
@@ -342,10 +387,6 @@ char *dirname PARAMS((char *path));
 /* error.c */
 void error PARAMS((int status, int errnum, char *message, ...));
 
-/* listfile.c */
-void list_file PARAMS((char *name, char *relname, struct stat *statp, time_t current_time, int output_block_size, FILE *stream));
-char *get_link_name PARAMS((char *name, char *relname));
-
 /* stpcpy.c */
 #if !HAVE_STPCPY
 char *stpcpy PARAMS((char *dest, const char *src));
@@ -379,15 +420,46 @@ void set_follow_state PARAMS((enum Symli
 void cleanup(void);
 
 /* fstype.c */
-char *filesystem_type PARAMS((const struct stat *statp));
+char *filesystem_type PARAMS((const struct stat *statp, const char *path));
 char * get_mounted_filesystems (void);
 dev_t * get_mounted_devices PARAMS((size_t *));
 
+
+
+enum arg_type
+  {
+    ARG_OPTION,			/* regular options like -maxdepth */
+    ARG_NOOP,			/* does nothing, returns true, internal use only */
+    ARG_POSITIONAL_OPTION,	/* options whose position is important (-follow) */
+    ARG_TEST,			/* a like -name */
+    ARG_SPECIAL_PARSE,		/* complex to parse, don't eat the test name before calling parse_xx(). */
+    ARG_PUNCTUATION,		/* like -o or ( */
+    ARG_ACTION			/* like -print */
+  };
+
+
+struct parser_table;
+/* Pointer to a parser function. */
+typedef boolean (*PARSE_FUNC)(const struct parser_table *p,
+			      char *argv[], int *arg_ptr);
+struct parser_table
+{
+  enum arg_type type;
+  char *parser_name;
+  PARSE_FUNC parser_func;
+  PRED_FUNC    pred_func;
+};
+
 /* parser.c */
-PFB find_parser PARAMS((char *search_name));
-boolean parse_close PARAMS((char *argv[], int *arg_ptr));
-boolean parse_open PARAMS((char *argv[], int *arg_ptr));
-boolean parse_print PARAMS((char *argv[], int *arg_ptr));
+const struct parser_table* find_parser PARAMS((char *search_name));
+boolean parse_open  PARAMS((const struct parser_table* entry, char *argv[], int *arg_ptr));
+boolean parse_close PARAMS((const struct parser_table* entry, char *argv[], int *arg_ptr));
+boolean parse_print PARAMS((const struct parser_table*, char *argv[], int *arg_ptr));
+void pred_sanity_check PARAMS((const struct predicate *predicates));
+void parse_begin_user_args PARAMS((char **args, int argno, const struct predicate *last, const struct predicate *predicates));
+void parse_end_user_args PARAMS((char **args, int argno, const struct predicate *last, const struct predicate *predicates));
+boolean parse_openparen              PARAMS((const struct parser_table* entry, char *argv[], int *arg_ptr));
+boolean parse_closeparen             PARAMS((const struct parser_table* entry, char *argv[], int *arg_ptr));
 
 /* pred.c */
 boolean pred_amin PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
@@ -403,6 +475,7 @@ boolean pred_delete PARAMS((char *pathna
 boolean pred_empty PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_exec PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_execdir PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
+boolean pred_executable PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_false PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_fls PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_fprint PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
@@ -423,6 +496,7 @@ boolean pred_mtime PARAMS((char *pathnam
 boolean pred_name PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_negate PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_newer PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
+boolean pred_newerXY PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_nogroup PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_nouser PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_ok PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
@@ -435,6 +509,7 @@ boolean pred_print PARAMS((char *pathnam
 boolean pred_print0 PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_prune PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_quit PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
+boolean pred_readable PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_regex PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_samefile PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_size PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
@@ -443,38 +518,62 @@ boolean pred_type PARAMS((char *pathname
 boolean pred_uid PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_used PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_user PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
+boolean pred_writable PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 boolean pred_xtype PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr));
 
+
+
 int launch PARAMS((const struct buildcmd_control *ctl,
 		   struct buildcmd_state *buildstate));
 
 
-char *find_pred_name PARAMS((PFB pred_func));
+char *find_pred_name PARAMS((PRED_FUNC pred_func));
 
 
 
-#ifdef DEBUG
+void print_predicate PARAMS((FILE *fp, const struct predicate *p));
 void print_tree PARAMS((FILE*, struct predicate *node, int indent));
 void print_list PARAMS((FILE*, struct predicate *node));
-void print_optlist PARAMS((FILE *fp, struct predicate *node));
-#endif /* DEBUG */
+void print_optlist PARAMS((FILE *fp, const struct predicate *node));
+
 
 /* tree.c */
-struct predicate *
-get_expr PARAMS((struct predicate **input, short int prev_prec));
-boolean opt_expr PARAMS((struct predicate **eval_treep));
-boolean mark_stat PARAMS((struct predicate *tree));
-boolean mark_type PARAMS((struct predicate *tree));
+struct predicate * build_expression_tree PARAMS((int argc, char *argv[], int end_of_leading_options));
+struct predicate * get_eval_tree PARAMS((void));
+struct predicate *get_new_pred PARAMS((const struct parser_table *entry));
+struct predicate *get_new_pred_chk_op PARAMS((const struct parser_table *entry));
+float  calculate_derived_rates PARAMS((struct predicate *p));
 
 /* util.c */
-struct predicate *get_new_pred PARAMS((void));
-struct predicate *get_new_pred_chk_op PARAMS((void));
-struct predicate *insert_primary PARAMS((boolean (*pred_func )()));
-void usage PARAMS((char *msg));
+struct predicate *insert_primary PARAMS((const struct parser_table *entry));
+struct predicate *insert_primary_withpred PARAMS((const struct parser_table *entry, PRED_FUNC fptr));
+void usage PARAMS((FILE *fp, int status, char *msg));
+extern boolean check_nofollow(void);
+void complete_pending_execs(struct predicate *p);
+void complete_pending_execdirs(int dirfd); /* Passing dirfd is an unpleasant CodeSmell. */
+
+int process_leading_options PARAMS((int argc, char *argv[]));
+void set_option_defaults PARAMS((struct options *p));
 
-extern char *program_name;
-extern struct predicate *predicates;
-extern struct predicate *last_pred;
+
+/* find.c. */
+int get_info PARAMS((const char *pathname, struct stat *p, struct predicate *pred_ptr));
+int following_links PARAMS((void));
+int digest_mode PARAMS((mode_t mode, const char *pathname, const char *name, struct stat *pstat, boolean leaf));
+boolean default_prints PARAMS((struct predicate *pred));
+boolean looks_like_expression PARAMS((const char *arg, boolean leading));
+
+
+enum DebugOption
+  {
+    DebugNone             = 0,
+    DebugExpressionTree   = 1,
+    DebugStat             = 2,
+    DebugSearch           = 4,
+    DebugTreeOpt          = 8,
+    DebugHelp             = 16,
+    DebugExec             = 32
+  };
 
 struct options
 {
@@ -498,11 +597,17 @@ struct options
    * no longer exists by the time we get around to processing it.
    */
   boolean ignore_readdir_race;
+
+  /* If true, pass control characters through.  If false, escape them
+   * or turn them into harmless things.
+   */
+  boolean literal_control_chars;
   
-/* If true, we issue warning messages
- */
+  /* If true, we issue warning messages
+   */
   boolean warnings;
-  time_t start_time;		/* Time at start of execution.  */
+  
+  struct timespec      start_time;		/* Time at start of execution.  */
   
   /* Seconds between 00:00 1/1/70 and either one day before now
      (the default), or the start of today (if -daystart is given). */
@@ -512,6 +617,9 @@ struct options
   boolean full_days;
   
   int output_block_size;	/* Output block size.  */
+
+  /* bitmask for debug options */
+  unsigned long debug_options;
   
   enum SymlinkOption symlink_handling;
   
@@ -524,6 +632,16 @@ struct options
    * flag to open(2). 
    */
   boolean open_nofollow_available;
+
+  /* The variety of regular expression that we support.
+   * The default is POSIX Basic Regular Expressions, but this 
+   * can be changed with the positional option, -regextype.
+   */
+  int regex_options;
+
+  /* Optimisation level.  One is the default. 
+   */
+  unsigned short optimisation_level;
 };
 extern struct options options;
 
@@ -543,9 +661,13 @@ struct state
   /* The file being operated on, relative to the current directory.
      Used for stat, readlink, remove, and opendir.  */
   char *rel_pathname;
+  /* The directory fd to which rel_pathname is relative.  Thsi is relevant
+   * when we're navigating the hierarchy with fts() and using FTS_CWDFD.
+   */
+  int cwd_dir_fd;
 
-  /* Length of current path. */
-  int path_length;
+  /* Length of starting path. */
+  int starting_path_length;
 
   /* If true, don't descend past current directory.
      Can be set by -prune, -maxdepth, and -xdev/-mount. */
@@ -553,13 +675,20 @@ struct state
   
   /* Status value to return to system. */
   int exit_status;
+
+  /* True if there are any execdirs.  This saves us a pair of fchdir()
+   * calls for every directory we leave if it is false.  This is just
+   * an optimisation.  Set to true if you want to be conservative.
+   */
+  boolean execdirs_outstanding;
 };
-extern struct state state;
 
+/* finddata.c */
+extern struct state state;
 extern char const *starting_dir;
 extern int starting_desc;
-#if ! defined HAVE_FCHDIR && ! defined fchdir
-# define fchdir(fd) (-1)
-#endif
+extern char *program_name;
+
+
 
 #endif
Only in dbg/find6/find/find/.deps: finddata.Po
diff -up -r dbg/find14/find/find/.deps/find.Po dbg/find6/find/find/.deps/find.Po
