--- dbg/find14/find/gnulib-cvs/gnulib/lib/readutmp.c	2020-01-28 23:47:42.000000000 -0600
+++ dbg/find6/find/gnulib-cvs/gnulib/lib/readutmp.c	2020-01-28 23:39:42.000000000 -0600
@@ -1,5 +1,7 @@
 /* GNU's read utmp module.
-   Copyright (C) 1992-2001, 2003, 2004 Free Software Foundation, Inc.
+
+   Copyright (C) 1992-2001, 2003, 2004, 2005, 2006 Free Software
+   Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -13,7 +15,7 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software Foundation,
-   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
 
 /* Written by jla; revised by djm */
 
@@ -26,6 +28,8 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <signal.h>
+#include <stdbool.h>
 #include <string.h>
 #include <stdlib.h>
 
@@ -35,6 +39,10 @@
 # include "unlocked-io.h"
 #endif
 
+#ifndef SIZE_MAX
+# define SIZE_MAX ((size_t) -1)
+#endif
+
 /* Copy UT->ut_name into storage obtained from malloc.  Then remove any
    trailing spaces from the copy, NUL terminate it, and return the copy.  */
 
@@ -56,40 +64,56 @@ extract_trimmed_name (const STRUCT_UTMP
   return trimmed_name;
 }
 
-/* Read the utmp entries corresponding to file FILENAME into freshly-
+/* Is the utmp entry U desired by the user who asked for OPTIONS?  */
+
+static inline bool
+desirable_utmp_entry (STRUCT_UTMP const *u, int options)
+{
+  bool user_proc = IS_USER_PROCESS (u);
+  if ((options & READ_UTMP_USER_PROCESS) && !user_proc)
+    return false;
+  if ((options & READ_UTMP_CHECK_PIDS)
+      && user_proc
+      && (UT_PID (u) <= 0
+	  || (kill (UT_PID (u), 0) < 0 && errno == ESRCH)))
+    return false;
+  return true;
+}
+
+/* Read the utmp entries corresponding to file FILE into freshly-
    malloc'd storage, set *UTMP_BUF to that pointer, set *N_ENTRIES to
    the number of entries, and return zero.  If there is any error,
-   return -1, setting errno, and don't modify the parameters.  */
+   return -1, setting errno, and don't modify the parameters.
+   If OPTIONS & READ_UTMP_CHECK_PIDS is nonzero, omit entries whose
+   process-IDs do not currently exist.  */
 
 #ifdef UTMP_NAME_FUNCTION
 
 int
-read_utmp (const char *filename, size_t *n_entries, STRUCT_UTMP **utmp_buf)
+read_utmp (char const *file, size_t *n_entries, STRUCT_UTMP **utmp_buf,
+	   int options)
 {
-  size_t n_read;
-  size_t n_alloc = 4;
-  STRUCT_UTMP *utmp = xmalloc (n_alloc * sizeof *utmp);
+  size_t n_read = 0;
+  size_t n_alloc = 0;
+  STRUCT_UTMP *utmp = NULL;
   STRUCT_UTMP *u;
 
   /* Ignore the return value for now.
      Solaris' utmpname returns 1 upon success -- which is contrary
      to what the GNU libc version does.  In addition, older GNU libc
      versions are actually void.   */
-  UTMP_NAME_FUNCTION (filename);
+  UTMP_NAME_FUNCTION (file);
 
   SET_UTMP_ENT ();
 
-  n_read = 0;
   while ((u = GET_UTMP_ENT ()) != NULL)
-    {
-      if (n_read == n_alloc)
-	{
-	  utmp = xnrealloc (utmp, n_alloc, 2 * sizeof *utmp);
-	  n_alloc *= 2;
-	}
-      ++n_read;
-      utmp[n_read - 1] = *u;
-    }
+    if (desirable_utmp_entry (u, options))
+      {
+	if (n_read == n_alloc)
+	  utmp = x2nrealloc (utmp, &n_alloc, sizeof *utmp);
+
+	utmp[n_read++] = *u;
+      }
 
   END_UTMP_ENT ();
 
@@ -102,46 +126,39 @@ read_utmp (const char *filename, size_t
 #else
 
 int
-read_utmp (const char *filename, size_t *n_entries, STRUCT_UTMP **utmp_buf)
+read_utmp (char const *file, size_t *n_entries, STRUCT_UTMP **utmp_buf,
+	   int options)
 {
-  FILE *utmp;
-  struct stat file_stats;
-  size_t n_read;
-  size_t size;
-  STRUCT_UTMP *buf;
+  size_t n_read = 0;
+  size_t n_alloc = 0;
+  STRUCT_UTMP *utmp = NULL;
+  int saved_errno;
+  FILE *f = fopen (file, "r");
 
-  utmp = fopen (filename, "r");
-  if (utmp == NULL)
+  if (! f)
     return -1;
 
-  if (fstat (fileno (utmp), &file_stats) != 0)
-    {
-      int e = errno;
-      fclose (utmp);
-      errno = e;
-      return -1;
-    }
-  size = file_stats.st_size;
-  buf = xmalloc (size);
-  n_read = fread (buf, sizeof *buf, size / sizeof *buf, utmp);
-  if (ferror (utmp))
+  for (;;)
     {
-      int e = errno;
-      free (buf);
-      fclose (utmp);
-      errno = e;
-      return -1;
+      if (n_read == n_alloc)
+	utmp = x2nrealloc (utmp, &n_alloc, sizeof *utmp);
+      if (fread (&utmp[n_read], sizeof utmp[n_read], 1, f) == 0)
+	break;
+      n_read += desirable_utmp_entry (&utmp[n_read], options);
     }
-  if (fclose (utmp) != 0)
+
+  saved_errno = ferror (f) ? errno : 0;
+  if (fclose (f) != 0)
+    saved_errno = errno;
+  if (saved_errno != 0)
     {
-      int e = errno;
-      free (buf);
-      errno = e;
+      free (utmp);
+      errno = saved_errno;
       return -1;
     }
 
   *n_entries = n_read;
-  *utmp_buf = buf;
+  *utmp_buf = utmp;
 
   return 0;
 }
diff -up -r dbg/find14/find/gnulib-cvs/gnulib/lib/readutmp.h dbg/find6/find/gnulib-cvs/gnulib/lib/readutmp.h
