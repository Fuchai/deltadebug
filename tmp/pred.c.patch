--- dbg/find14/find/find/pred.c	2020-01-28 23:47:42.000000000 -0600
+++ dbg/find6/find/find/pred.c	2020-01-28 23:39:42.000000000 -0600
@@ -1,5 +1,6 @@
 /* pred.c -- execute the expression tree.
-   Copyright (C) 1990, 91, 92, 93, 94, 2000, 2003, 2004 Free Software Foundation, Inc.
+   Copyright (C) 1990, 1991, 1992, 1993, 1994, 2000, 2003, 
+                 2004, 2005 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -13,7 +14,7 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
    USA.
 */
 
@@ -21,19 +22,27 @@
 
 #include <fnmatch.h>
 #include <signal.h>
+#include <math.h>
 #include <pwd.h>
 #include <grp.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <assert.h>
 #include <fcntl.h>
-#include "../gnulib/lib/xalloc.h"
-#include "../gnulib/lib/dirname.h"
-#include "../gnulib/lib/human.h"
+#include <locale.h>
+#include <openat.h>
+#include "xalloc.h"
+#include "dirname.h"
+#include "human.h"
 #include "modetype.h"
 #include "filemode.h"
 #include "wait.h"
+#include "printquoted.h"
 #include "buildcmd.h"
+#include "yesno.h"
+#include "listfile.h"
+#include "stat-time.h"
+#include "dircallback.h"
 
 #if ENABLE_NLS
 # include <libintl.h>
@@ -52,6 +61,8 @@
 #define SIGCHLD SIGCLD
 #endif
 
+
+
 #if HAVE_DIRENT_H
 # include <dirent.h>
 # define NAMLEN(dirent) strlen((dirent)->d_name)
@@ -76,7 +87,7 @@
 #define CLOSEDIR(d) closedir (d)
 #endif
 
-extern int yesno ();
+
 
 
 /* Get or fake the disk device blocksize.
@@ -140,18 +151,19 @@ extern int yesno ();
 # define ST_NBLOCKSIZE 512
 #endif
 
+
 #undef MAX
 #define MAX(a, b) ((a) > (b) ? (a) : (b))
 
-static boolean insert_lname PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr, boolean ignore_case));
+static boolean match_lname PARAMS((char *pathname, struct stat *stat_buf, struct predicate *pred_ptr, boolean ignore_case));
 
-static char *format_date PARAMS((time_t when, int kind));
-static char *ctime_format PARAMS((time_t when));
+static char *format_date PARAMS((struct timespec ts, int kind));
+static char *ctime_format PARAMS((struct timespec ts));
 
 #ifdef	DEBUG
 struct pred_assoc
 {
-  PFB pred_func;
+  PRED_FUNC pred_func;
   char *pred_name;
 };
 
@@ -162,7 +174,7 @@ struct pred_assoc pred_table[] =
   {pred_anewer, "anewer  "},
   {pred_atime, "atime   "},
   {pred_close, ")       "},
-  {pred_amin, "cmin    "},
+  {pred_cmin, "cmin    "},
   {pred_cnewer, "cnewer  "},
   {pred_comma, ",       "},
   {pred_ctime, "ctime   "},
@@ -170,6 +182,7 @@ struct pred_assoc pred_table[] =
   {pred_empty, "empty   "},
   {pred_exec, "exec    "},
   {pred_execdir, "execdir "},
+  {pred_executable, "executable "},
   {pred_false, "false   "},
   {pred_fprint, "fprint  "},
   {pred_fprint0, "fprint0 "},
@@ -184,11 +197,12 @@ struct pred_assoc pred_table[] =
   {pred_links, "links   "},
   {pred_lname, "lname   "},
   {pred_ls, "ls      "},
-  {pred_amin, "mmin    "},
+  {pred_mmin, "mmin    "},
   {pred_mtime, "mtime   "},
   {pred_name, "name    "},
   {pred_negate, "not     "},
   {pred_newer, "newer   "},
+  {pred_newerXY, "newerXY   "},
   {pred_nogroup, "nogroup "},
   {pred_nouser, "nouser  "},
   {pred_ok, "ok      "},
@@ -200,6 +214,8 @@ struct pred_assoc pred_table[] =
   {pred_print, "print   "},
   {pred_print0, "print0  "},
   {pred_prune, "prune   "},
+  {pred_quit, "quit    "},
+  {pred_readable, "readable    "},
   {pred_regex, "regex   "},
   {pred_samefile,"samefile "},
   {pred_size, "size    "},
@@ -208,44 +224,37 @@ struct pred_assoc pred_table[] =
   {pred_uid, "uid     "},
   {pred_used, "used    "},
   {pred_user, "user    "},
+  {pred_writable, "writable "},
   {pred_xtype, "xtype   "},
   {0, "none    "}
 };
+#endif
+
+/* Returns ts1 - ts2 */
+static double ts_difference(struct timespec ts1,
+			    struct timespec ts2)
+{
+  double d =  difftime(ts1.tv_sec, ts2.tv_sec) 
+    + (1.0e-9 * (ts1.tv_nsec - ts2.tv_nsec));
+  return d;
+}
 
-struct op_assoc
-{
-  short type;
-  char *type_name;
-};
-
-struct op_assoc type_table[] =
-{
-  {NO_TYPE, "no          "},
-  {PRIMARY_TYPE, "primary      "},
-  {UNI_OP, "uni_op      "},
-  {BI_OP, "bi_op       "},
-  {OPEN_PAREN, "open_paren  "},
-  {CLOSE_PAREN, "close_paren "},
-  {-1, "unknown     "}
-};
-
-struct prec_assoc
-{
-  short prec;
-  char *prec_name;
-};
-
-struct prec_assoc prec_table[] =
+
+static int 
+compare_ts(struct timespec ts1,
+	   struct timespec ts2)
 {
-  {NO_PREC, "no      "},
-  {COMMA_PREC, "comma   "},
-  {OR_PREC, "or      "},
-  {AND_PREC, "and     "},
-  {NEGATE_PREC, "negate  "},
-  {MAX_PREC, "max     "},
-  {-1, "unknown "}
-};
-#endif	/* DEBUG */
+  if ((ts1.tv_sec == ts2.tv_sec) &&
+      (ts1.tv_nsec == ts2.tv_nsec))
+    {
+      return 0;
+    }
+  else
+    {
+      double diff = ts_difference(ts1, ts2);
+      return diff < 0.0 ? -1 : +1;
+    }
+}
 
 /* Predicate processing routines.
  
@@ -264,25 +273,22 @@ struct prec_assoc prec_table[] =
  * COMP_EQ: less than WINDOW seconds after the specified time.
  */
 static boolean
-pred_timewindow(time_t the_time, struct predicate const *pred_ptr, int window)
+pred_timewindow(struct timespec ts, struct predicate const *pred_ptr, int window)
 {
-  switch (pred_ptr->args.info.kind)
+  double delta;
+  
+  switch (pred_ptr->args.reftime.kind)
     {
     case COMP_GT:
-      if (the_time > (time_t) pred_ptr->args.info.l_val)
-	return true;
-      break;
+      return compare_ts(ts, pred_ptr->args.reftime.ts) > 0;
+      
     case COMP_LT:
-      if (the_time < (time_t) pred_ptr->args.info.l_val)
-	return true;
-      break;
+      return compare_ts(ts, pred_ptr->args.reftime.ts) < 0;
+      
     case COMP_EQ:
-      if ((the_time >= (time_t) pred_ptr->args.info.l_val)
-	  && (the_time < (time_t) pred_ptr->args.info.l_val + window))
-	return true;
-      break;
+      delta = ts_difference(ts, pred_ptr->args.reftime.ts);
+      return (delta >= 0.0 && delta < window);
     }
-  return false;
 }
 
 
@@ -290,7 +296,7 @@ boolean
 pred_amin (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
   (void) &pathname;
-  return pred_timewindow(stat_buf->st_atime, pred_ptr, 60);
+  return pred_timewindow(get_stat_atime(stat_buf), pred_ptr, 60);
 }
 
 boolean
@@ -301,7 +307,7 @@ pred_and (char *pathname, struct stat *s
 					    pred_ptr->pred_left))
     {
       /* Check whether we need a stat here. */
-      if (get_info(pathname, state.rel_pathname, stat_buf, pred_ptr) != 0)
+      if (get_info(pathname, stat_buf, pred_ptr) != 0)
 	    return false;
       return ((*pred_ptr->pred_right->pred_func) (pathname, stat_buf,  
 						  pred_ptr->pred_right));
@@ -314,17 +320,15 @@ boolean
 pred_anewer (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
   (void) &pathname;
-  
-  if (stat_buf->st_atime > pred_ptr->args.time)
-    return (true);
-  return (false);
+  assert(COMP_GT == pred_ptr->args.reftime.kind);
+  return compare_ts(get_stat_atime(stat_buf), pred_ptr->args.reftime.ts) > 0;
 }
 
 boolean
 pred_atime (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
   (void) &pathname;
-  return pred_timewindow(stat_buf->st_atime, pred_ptr, DAYSECS);
+  return pred_timewindow(get_stat_atime(stat_buf), pred_ptr, DAYSECS);
 }
 
 boolean
@@ -341,7 +345,7 @@ boolean
 pred_cmin (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
   (void) pathname;
-  return pred_timewindow(stat_buf->st_ctime, pred_ptr, 60);
+  return pred_timewindow(get_stat_ctime(stat_buf), pred_ptr, 60);
 }
 
 boolean
@@ -349,10 +353,8 @@ pred_cnewer (char *pathname, struct stat
 {
   (void) pathname;
   
-  if (stat_buf->st_ctime > pred_ptr->args.time)
-    return true;
-  else
-    return false;
+  assert(COMP_GT == pred_ptr->args.reftime.kind);
+  return compare_ts(get_stat_ctime(stat_buf), pred_ptr->args.reftime.ts) > 0;
 }
 
 boolean
@@ -363,7 +365,7 @@ pred_comma (char *pathname, struct stat
 				       pred_ptr->pred_left);
   /* Check whether we need a stat here. */
   /* TODO: what about need_type? */
-  if (get_info(pathname, state.rel_pathname, stat_buf, pred_ptr) != 0)
+  if (get_info(pathname, stat_buf, pred_ptr) != 0)
     return false;
   return ((*pred_ptr->pred_right->pred_func) (pathname, stat_buf,
 					      pred_ptr->pred_right));
@@ -373,7 +375,7 @@ boolean
 pred_ctime (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
   (void) &pathname;
-  return pred_timewindow(stat_buf->st_ctime, pred_ptr, DAYSECS);
+  return pred_timewindow(get_stat_ctime(stat_buf), pred_ptr, DAYSECS);
 }
 
 boolean
@@ -383,7 +385,10 @@ pred_delete (char *pathname, struct stat
   (void) stat_buf;
   if (strcmp (state.rel_pathname, "."))
     {
-      if (0 != remove (state.rel_pathname))
+      int flags=0;
+      if (S_ISDIR(stat_buf->st_mode))
+	flags |= AT_REMOVEDIR;
+      if (0 != unlinkat(state.cwd_dir_fd, state.rel_pathname, flags))
 	{
 	  error (0, errno, "cannot delete %s", pathname);
 	  return false;
@@ -406,12 +411,19 @@ pred_empty (char *pathname, struct stat
   
   if (S_ISDIR (stat_buf->st_mode))
     {
+      int fd;
       DIR *d;
       struct dirent *dp;
       boolean empty = true;
 
       errno = 0;
-      d = opendir (state.rel_pathname);
+      if ((fd = openat(state.cwd_dir_fd, state.rel_pathname, O_RDONLY|O_LARGEFILE)) < 0)
+	{
+	  error (0, errno, "%s", pathname);
+	  state.exit_status = 1;
+	  return false;
+	}
+      d = fdopendir (fd);
       if (d == NULL)
 	{
 	  error (0, errno, "%s", pathname);
@@ -443,13 +455,16 @@ pred_empty (char *pathname, struct stat
 }
 
 static boolean
-new_impl_pred_exec (const char *pathname, struct stat *stat_buf,
+new_impl_pred_exec (int dirfd, const char *pathname,
+		    struct stat *stat_buf,
 		    struct predicate *pred_ptr,
 		    const char *prefix, size_t pfxlen)
 {
   struct exec_val *execp = &pred_ptr->args.exec_vec;
   size_t len = strlen(pathname);
-  
+
+  (void) stat_buf;
+  execp->dirfd = dirfd;
   if (execp->multiple)
     {
       /* Push the argument onto the current list. 
@@ -461,6 +476,9 @@ new_impl_pred_exec (const char *pathname
 		  pathname, len+1,
 		  prefix, pfxlen,
 		  0);
+
+      /* remember that there are pending execdirs. */
+      state.execdirs_outstanding = true;
       
       /* POSIX: If the primary expression is punctuated by a plus
        * sign, the primary shall always evaluate as true
@@ -492,7 +510,8 @@ new_impl_pred_exec (const char *pathname
 boolean
 pred_exec (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
-  return new_impl_pred_exec(pathname, stat_buf, pred_ptr, NULL, 0);
+  return new_impl_pred_exec(get_start_dirfd(),
+			    pathname, stat_buf, pred_ptr, NULL, 0);
 }
 
 boolean
@@ -500,7 +519,8 @@ pred_execdir (char *pathname, struct sta
 {
    const char *prefix = (state.rel_pathname[0] == '/') ? NULL : "./";
    (void) &pathname;
-   return new_impl_pred_exec (state.rel_pathname, stat_buf, pred_ptr,
+   return new_impl_pred_exec (get_current_dirfd(),
+			      state.rel_pathname, stat_buf, pred_ptr,
 			      prefix, (prefix ? 2 : 0));
 }
 
@@ -518,9 +538,10 @@ pred_false (char *pathname, struct stat
 boolean
 pred_fls (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
-  list_file (pathname, state.rel_pathname, stat_buf, options.start_time,
-	     options.output_block_size, pred_ptr->args.stream);
-  return (true);
+  list_file (pathname, state.cwd_dir_fd, state.rel_pathname, stat_buf, options.start_time.tv_sec,
+	     options.output_block_size,
+	     pred_ptr->literal_control_chars, pred_ptr->args.stream);
+  return true;
 }
 
 boolean
@@ -529,9 +550,12 @@ pred_fprint (char *pathname, struct stat
   (void) &pathname;
   (void) &stat_buf;
   
-  fputs (pathname, pred_ptr->args.stream);
-  putc ('\n', pred_ptr->args.stream);
-  return (true);
+  print_quoted(pred_ptr->args.printf_vec.stream,
+	       pred_ptr->args.printf_vec.quote_opts,
+	       pred_ptr->args.printf_vec.dest_is_tty,
+	       "%s\n",
+	       pathname);
+  return true;
 }
 
 boolean
@@ -545,76 +569,108 @@ pred_fprint0 (char *pathname, struct sta
   return (true);
 }
 
-boolean
-pred_fprintf (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
+
+
+static char*
+mode_to_filetype(mode_t m)
 {
-  FILE *fp = pred_ptr->args.printf_vec.stream;
-  struct segment *segment;
-  char *cp;
-  char hbuf[LONGEST_HUMAN_READABLE + 1];
+  return
+    m == S_IFSOCK ? "s" :
+    m == S_IFLNK  ? "l" :
+    m == S_IFREG  ? "f" :
+    m == S_IFBLK  ? "b" :
+    m == S_IFDIR  ? "d" :
+    m == S_IFCHR  ? "c" :
+#ifdef S_IFDOOR
+    m == S_IFDOOR ? "D" :
+#endif
+    m == S_IFIFO  ? "p" : "U";
+}
 
-  for (segment = pred_ptr->args.printf_vec.segment; segment;
-       segment = segment->next)
+static double 
+file_sparseness(const struct stat *p)
+{
+  if (0 == p->st_size)
     {
-      if (segment->kind & 0xff00) /* Component of date. */
-	{
-	  time_t t;
+      if (0 == p->st_blocks)
+	return 1.0;
+      else
+	return p->st_blocks < 0 ? -HUGE_VAL : HUGE_VAL;
+    }
+  else
+    {
+      double blklen = file_blocksize(p) * (double)p->st_blocks;
+      return blklen / p->st_size;
+    }
+}
+
 
-	  switch (segment->kind & 0xff)
-	    {
-	    case 'A':
-	      t = stat_buf->st_atime;
-	      break;
-	    case 'C':
-	      t = stat_buf->st_ctime;
-	      break;
-	    case 'T':
-	      t = stat_buf->st_mtime;
-	      break;
-	    default:
-	      abort ();
-	    }
-	  fprintf (fp, segment->text,
-		   format_date (t, (segment->kind >> 8) & 0xff));
-	  continue;
-	}
 
-      switch (segment->kind)
+static boolean
+do_fprintf(FILE *fp,
+	   struct segment *segment,
+	   char *pathname,
+	   const struct stat *stat_buf,
+	   boolean ttyflag,
+	   const struct quoting_options *qopts)
+{
+  char hbuf[LONGEST_HUMAN_READABLE + 1];
+  char *cp;
+
+  switch (segment->segkind)
+    {
+    case KIND_PLAIN:	/* Plain text string (no % conversion). */
+      /* trusted */
+      fwrite (segment->text, 1, segment->text_len, fp);
+      break;
+	  
+    case KIND_STOP:		/* Terminate argument and flush output. */
+      /* trusted */
+      fwrite (segment->text, 1, segment->text_len, fp);
+      fflush (fp);
+      return (true);
+	  
+    case KIND_FORMAT:
+      switch (segment->format_char[0])
 	{
-	case KIND_PLAIN:	/* Plain text string (no % conversion). */
-	  fwrite (segment->text, 1, segment->text_len, fp);
-	  break;
-	case KIND_STOP:		/* Terminate argument and flush output. */
-	  fwrite (segment->text, 1, segment->text_len, fp);
-	  fflush (fp);
-	  return (true);
 	case 'a':		/* atime in `ctime' format. */
-	  fprintf (fp, segment->text, ctime_format (stat_buf->st_atime));
+	  /* UNTRUSTED, probably unexploitable */
+	  fprintf (fp, segment->text, ctime_format (get_stat_atime(stat_buf)));
 	  break;
 	case 'b':		/* size in 512-byte blocks */
+	  /* UNTRUSTED, probably unexploitable */
 	  fprintf (fp, segment->text,
 		   human_readable ((uintmax_t) ST_NBLOCKS (*stat_buf),
 				   hbuf, human_ceiling,
 				   ST_NBLOCKSIZE, 512));
 	  break;
 	case 'c':		/* ctime in `ctime' format */
-	  fprintf (fp, segment->text, ctime_format (stat_buf->st_ctime));
+	  /* UNTRUSTED, probably unexploitable */
+	  fprintf (fp, segment->text, ctime_format (get_stat_ctime(stat_buf)));
 	  break;
 	case 'd':		/* depth in search tree */
+	  /* UNTRUSTED, probably unexploitable */
 	  fprintf (fp, segment->text, state.curdepth);
 	  break;
 	case 'D':		/* Device on which file exists (stat.st_dev) */
+	  /* trusted */
 	  fprintf (fp, segment->text, 
 		   human_readable ((uintmax_t) stat_buf->st_dev, hbuf,
 				   human_ceiling, 1, 1));
 	  break;
 	case 'f':		/* base name of path */
-	  fprintf (fp, segment->text, base_name (pathname));
+	  /* sanitised */
+	  print_quoted (fp, qopts, ttyflag, segment->text, base_name (pathname));
 	  break;
 	case 'F':		/* filesystem type */
-	  fprintf (fp, segment->text, filesystem_type (stat_buf));
+	  /* trusted */
+	  print_quoted (fp, qopts, ttyflag, segment->text, filesystem_type (stat_buf, pathname));
 	  break;
 	case 'g':		/* group name */
+	  /* trusted */
+	  /* (well, the actual group is selected by the user but
+	   * its name was selected by the system administrator)
+	   */
 	  {
 	    struct group *g;
 
@@ -625,79 +681,105 @@ pred_fprintf (char *pathname, struct sta
 		fprintf (fp, segment->text, g->gr_name);
 		break;
 	      }
-	    /* else fallthru */
+	    else
+	      {
+		/* Do nothing. */
+		/*FALLTHROUGH*/
+	      }
 	  }
 	case 'G':		/* GID number */
+	  /* UNTRUSTED, probably unexploitable */
 	  fprintf (fp, segment->text,
 		   human_readable ((uintmax_t) stat_buf->st_gid, hbuf,
 				   human_ceiling, 1, 1));
 	  break;
 	case 'h':		/* leading directories part of path */
+	  /* sanitised */
 	  {
 	    char cc;
-
+	    
 	    cp = strrchr (pathname, '/');
 	    if (cp == NULL)	/* No leading directories. */
-	      break;
-	    cc = *cp;
-	    *cp = '\0';
-	    fprintf (fp, segment->text, pathname);
-	    *cp = cc;
+	      {
+		/* If there is no slash in the pathname, we still
+		 * print the string because it contains characters
+		 * other than just '%s'.  The %h expands to ".".
+		 */
+		print_quoted (fp, qopts, ttyflag, segment->text, ".");
+	      }
+	    else
+	      {
+		cc = *cp;
+		*cp = '\0';
+		print_quoted (fp, qopts, ttyflag, segment->text, pathname);
+		*cp = cc;
+	      }
 	    break;
 	  }
 	case 'H':		/* ARGV element file was found under */
+	  /* trusted */
 	  {
-	    char cc = pathname[state.path_length];
+	    char cc = pathname[state.starting_path_length];
 
-	    pathname[state.path_length] = '\0';
+	    pathname[state.starting_path_length] = '\0';
 	    fprintf (fp, segment->text, pathname);
-	    pathname[state.path_length] = cc;
+	    pathname[state.starting_path_length] = cc;
 	    break;
 	  }
 	case 'i':		/* inode number */
+	  /* UNTRUSTED, but not exploitable I think */
 	  fprintf (fp, segment->text,
 		   human_readable ((uintmax_t) stat_buf->st_ino, hbuf,
 				   human_ceiling,
 				   1, 1));
 	  break;
 	case 'k':		/* size in 1K blocks */
+	  /* UNTRUSTED, but not exploitable I think */
 	  fprintf (fp, segment->text,
 		   human_readable ((uintmax_t) ST_NBLOCKS (*stat_buf),
 				   hbuf, human_ceiling,
 				   ST_NBLOCKSIZE, 1024)); 
 	  break;
 	case 'l':		/* object of symlink */
+	  /* sanitised */
 #ifdef S_ISLNK
 	  {
 	    char *linkname = 0;
 
 	    if (S_ISLNK (stat_buf->st_mode))
 	      {
-		linkname = get_link_name (pathname, state.rel_pathname);
+		linkname = get_link_name_at (pathname, state.cwd_dir_fd, state.rel_pathname);
 		if (linkname == 0)
 		  state.exit_status = 1;
 	      }
 	    if (linkname)
 	      {
-		fprintf (fp, segment->text, linkname);
+		print_quoted (fp, qopts, ttyflag, segment->text, linkname);
 		free (linkname);
 	      }
 	    else
-	      fprintf (fp, segment->text, "");
+	      {
+		/* We still need to honour the field width etc., so this is
+		 * not a no-op.
+		 */
+		print_quoted (fp, qopts, ttyflag, segment->text, "");
+	      }
 	  }
 #endif				/* S_ISLNK */
 	  break;
-	  
+
 	case 'M':		/* mode as 10 chars (eg., "-rwxr-x--x" */
+	  /* UNTRUSTED, probably unexploitable */
 	  {
 	    char modestring[16] ;
-	    mode_string (stat_buf->st_mode, modestring);
+	    filemodestring (stat_buf, modestring);
 	    modestring[10] = '\0';
 	    fprintf (fp, segment->text, modestring);
 	  }
 	  break;
-	  
+
 	case 'm':		/* mode as octal number (perms only) */
+	  /* UNTRUSTED, probably unexploitable */
 	  {
 	    /* Output the mode portably using the traditional numbers,
 	       even if the host unwisely uses some other numbering
@@ -728,6 +810,7 @@ pred_fprintf (char *pathname, struct sta
 	  break;
 	  
 	case 'n':		/* number of links */
+	  /* UNTRUSTED, probably unexploitable */
 	  fprintf (fp, segment->text,
 		   human_readable ((uintmax_t) stat_buf->st_nlink,
 				   hbuf,
@@ -735,12 +818,14 @@ pred_fprintf (char *pathname, struct sta
 				   1, 1));
 	  break;
 	case 'p':		/* pathname */
-	  fprintf (fp, segment->text, pathname);
+	  /* sanitised */
+	  print_quoted (fp, qopts, ttyflag, segment->text, pathname);
 	  break;
 	case 'P':		/* pathname with ARGV element stripped */
+	  /* sanitised */
 	  if (state.curdepth > 0)
 	    {
-	      cp = pathname + state.path_length;
+	      cp = pathname + state.starting_path_length;
 	      if (*cp == '/')
 		/* Move past the slash between the ARGV element
 		   and the rest of the pathname.  But if the ARGV element
@@ -750,17 +835,31 @@ pred_fprintf (char *pathname, struct sta
 	    }
 	  else
 	    cp = "";
-	  fprintf (fp, segment->text, cp);
+	  print_quoted (fp, qopts, ttyflag, segment->text, cp);
 	  break;
 	case 's':		/* size in bytes */
+	  /* UNTRUSTED, probably unexploitable */
 	  fprintf (fp, segment->text,
 		   human_readable ((uintmax_t) stat_buf->st_size,
 				   hbuf, human_ceiling, 1, 1));
 	  break;
+	  
+	case 'S':		/* sparseness */
+	  /* UNTRUSTED, probably unexploitable */
+	  fprintf (fp, segment->text, file_sparseness(stat_buf));;
+	  break;
+	  
 	case 't':		/* mtime in `ctime' format */
-	  fprintf (fp, segment->text, ctime_format (stat_buf->st_mtime));
+	  /* UNTRUSTED, probably unexploitable */
+	  fprintf (fp, segment->text, ctime_format (get_stat_mtime(stat_buf)));
 	  break;
+	  
 	case 'u':		/* user name */
+	  /* trusted */
+	  /* (well, the actual user is selected by the user on systems
+	   * where chown is not restricted, but the user name was
+	   * selected by the system administrator)
+	   */
 	  {
 	    struct passwd *p;
 
@@ -775,62 +874,131 @@ pred_fprintf (char *pathname, struct sta
 	  }
 	  
 	case 'U':		/* UID number */
+	  /* UNTRUSTED, probably unexploitable */
 	  fprintf (fp, segment->text,
 		   human_readable ((uintmax_t) stat_buf->st_uid, hbuf,
 				   human_ceiling, 1, 1));
 	  break;
 
-	/* type of filesystem entry like `ls -l`: (d,-,l,s,p,b,c,n) n=nonexistent(symlink) */
+	  /* type of filesystem entry like `ls -l`: (d,-,l,s,p,b,c,n) n=nonexistent(symlink) */
 	case 'Y':		/* in case of symlink */
+	  /* trusted */
 	  {
 #ifdef S_ISLNK
-	  if (S_ISLNK (stat_buf->st_mode))
-	    {
-	      struct stat sbuf;
-	      /* If we would normally follow links, do not do so.
-	       * If we would normally not follow links, do so.
-	       */
-	      if ((following_links() ? lstat : stat)
-		  (state.rel_pathname, &sbuf) != 0)
+	    if (S_ISLNK (stat_buf->st_mode))
 	      {
-		if ( errno == ENOENT ) {
-		  fprintf (fp, segment->text, "N");
-		  break;
-		};
-		if ( errno == ELOOP ) {
-		  fprintf (fp, segment->text, "L");
-		  break;
-		};
-		error (0, errno, "%s", pathname);
-		/* exit_status = 1;
-		return (false); */
+		struct stat sbuf;
+		/* If we would normally follow links, do not do so.
+		 * If we would normally not follow links, do so.
+		 */
+		if ((following_links() ? lstat : stat)
+		    (state.rel_pathname, &sbuf) != 0)
+		  {
+		    if ( errno == ENOENT ) {
+		      fprintf (fp, segment->text, "N");
+		      break;
+		    };
+		    if ( errno == ELOOP ) {
+		      fprintf (fp, segment->text, "L");
+		      break;
+		    };
+		    error (0, errno, "%s", pathname);
+		    /* exit_status = 1;
+		       return (false); */
+		  }
+		fprintf (fp, segment->text,
+			 mode_to_filetype(sbuf.st_mode & S_IFMT));
 	      }
-	      stat_buf->st_mode = sbuf.st_mode;
-	    }
 #endif /* S_ISLNK */
+	    else
+	      {
+		fprintf (fp, segment->text,
+			 mode_to_filetype(stat_buf->st_mode & S_IFMT));
+	      }
 	  }
-	  /* FALLTHROUGH */
+	  break;
+
 	case 'y':
+	  /* trusted */
 	  {
-	    mode_t m = stat_buf->st_mode & S_IFMT;
-
 	    fprintf (fp, segment->text,
-		( m == S_IFSOCK ? "s" :
-		  m == S_IFLNK  ? "l" :
-		  m == S_IFREG  ? "f" :
-		  m == S_IFBLK  ? "b" :
-		  m == S_IFDIR  ? "d" :
-		  m == S_IFCHR  ? "c" :
-#ifdef S_IFDOOR
-		  m == S_IFDOOR ? "D" :
-#endif
-		  m == S_IFIFO  ? "p" : "U" ) );
-
+		     mode_to_filetype(stat_buf->st_mode & S_IFMT));
 	  }
 	  break;
 	}
+      break;
     }
-  return (true);
+  #warning this function needs a return statement.  See Savannah bug#19146.
+}
+
+boolean
+pred_fprintf (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
+{
+  FILE *fp = pred_ptr->args.printf_vec.stream;
+  struct segment *segment;
+  boolean ttyflag = pred_ptr->args.printf_vec.dest_is_tty;
+  const struct quoting_options *qopts = pred_ptr->args.printf_vec.quote_opts;
+
+  for (segment = pred_ptr->args.printf_vec.segment; segment;
+       segment = segment->next)
+    {
+      if ( (KIND_FORMAT == segment->segkind) && segment->format_char[1]) /* Component of date. */
+	{
+	  struct timespec ts;
+	  int valid = 0;
+	  
+	  switch (segment->format_char[0])
+	    {
+	    case 'A':
+	      ts = get_stat_atime(stat_buf);
+	      valid = 1;
+	      break;
+	    case 'B':
+	      ts = get_stat_birthtime(stat_buf);
+	      if ('@' == segment->format_char[1])
+		valid = 1;
+	      else
+		valid = (ts.tv_nsec >= 0);
+	      break;
+	    case 'C':
+	      ts = get_stat_ctime(stat_buf);
+	      valid = 1;
+	      break;
+	    case 'T':
+	      ts = get_stat_mtime(stat_buf);
+	      valid = 1;
+	      break;
+	    default:
+	      assert(0);
+	      abort ();
+	    }
+	  /* We trust the output of format_date not to contain 
+	   * nasty characters, though the value of the date
+	   * is itself untrusted data.
+	   */
+	  if (valid)
+	    {
+	      /* trusted */
+	      fprintf (fp, segment->text,
+		       format_date (ts, segment->format_char[1]));
+	    }
+	  else
+	    {
+	      /* The specified timestamp is not available, output
+	       * nothing for the timestamp, but use the rest (so that
+	       * for example find foo -printf '[%Bs] %p\n' can print
+	       * "[] foo").
+	       */
+	      /* trusted */
+	      fprintf (fp, segment->text, "");
+	    }
+	}
+      else
+	{
+	  do_fprintf(fp, segment, pathname, stat_buf, ttyflag, qopts);
+	}
+    }
+  return true;
 }
 
 boolean
@@ -838,7 +1006,7 @@ pred_fstype (char *pathname, struct stat
 {
   (void) pathname;
   
-  if (strcmp (filesystem_type (stat_buf), pred_ptr->args.str) == 0)
+  if (strcmp (filesystem_type (stat_buf, pathname), pred_ptr->args.str) == 0)
     return true;
   else
     return false;
@@ -849,18 +1017,18 @@ pred_gid (char *pathname, struct stat *s
 {
   (void) pathname;
   
-  switch (pred_ptr->args.info.kind)
+  switch (pred_ptr->args.numinfo.kind)
     {
     case COMP_GT:
-      if (stat_buf->st_gid > pred_ptr->args.info.l_val)
+      if (stat_buf->st_gid > pred_ptr->args.numinfo.l_val)
 	return (true);
       break;
     case COMP_LT:
-      if (stat_buf->st_gid < pred_ptr->args.info.l_val)
+      if (stat_buf->st_gid < pred_ptr->args.numinfo.l_val)
 	return (true);
       break;
     case COMP_EQ:
-      if (stat_buf->st_gid == pred_ptr->args.info.l_val)
+      if (stat_buf->st_gid == pred_ptr->args.numinfo.l_val)
 	return (true);
       break;
     }
@@ -881,7 +1049,7 @@ pred_group (char *pathname, struct stat
 boolean
 pred_ilname (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
-  return insert_lname (pathname, stat_buf, pred_ptr, true);
+  return match_lname (pathname, stat_buf, pred_ptr, true);
 }
 
 boolean
@@ -905,18 +1073,18 @@ pred_inum (char *pathname, struct stat *
 {
   (void) pathname;
   
-  switch (pred_ptr->args.info.kind)
+  switch (pred_ptr->args.numinfo.kind)
     {
     case COMP_GT:
-      if (stat_buf->st_ino > pred_ptr->args.info.l_val)
+      if (stat_buf->st_ino > pred_ptr->args.numinfo.l_val)
 	return (true);
       break;
     case COMP_LT:
-      if (stat_buf->st_ino < pred_ptr->args.info.l_val)
+      if (stat_buf->st_ino < pred_ptr->args.numinfo.l_val)
 	return (true);
       break;
     case COMP_EQ:
-      if (stat_buf->st_ino == pred_ptr->args.info.l_val)
+      if (stat_buf->st_ino == pred_ptr->args.numinfo.l_val)
 	return (true);
       break;
     }
@@ -938,18 +1106,18 @@ pred_links (char *pathname, struct stat
 {
   (void) pathname;
   
-  switch (pred_ptr->args.info.kind)
+  switch (pred_ptr->args.numinfo.kind)
     {
     case COMP_GT:
-      if (stat_buf->st_nlink > pred_ptr->args.info.l_val)
+      if (stat_buf->st_nlink > pred_ptr->args.numinfo.l_val)
 	return (true);
       break;
     case COMP_LT:
-      if (stat_buf->st_nlink < pred_ptr->args.info.l_val)
+      if (stat_buf->st_nlink < pred_ptr->args.numinfo.l_val)
 	return (true);
       break;
     case COMP_EQ:
-      if (stat_buf->st_nlink == pred_ptr->args.info.l_val)
+      if (stat_buf->st_nlink == pred_ptr->args.numinfo.l_val)
 	return (true);
       break;
     }
@@ -959,17 +1127,17 @@ pred_links (char *pathname, struct stat
 boolean
 pred_lname (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
-  return insert_lname (pathname, stat_buf, pred_ptr, false);
+  return match_lname (pathname, stat_buf, pred_ptr, false);
 }
 
 static boolean
-insert_lname (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr, boolean ignore_case)
+match_lname (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr, boolean ignore_case)
 {
   boolean ret = false;
 #ifdef S_ISLNK
   if (S_ISLNK (stat_buf->st_mode))
     {
-      char *linkname = get_link_name (pathname, state.rel_pathname);
+      char *linkname = get_link_name_at (pathname, state.cwd_dir_fd, state.rel_pathname);
       if (linkname)
 	{
 	  if (fnmatch (pred_ptr->args.str, linkname,
@@ -979,31 +1147,32 @@ insert_lname (char *pathname, struct sta
 	}
     }
 #endif /* S_ISLNK */
-  return (ret);
+  return ret;
 }
 
 boolean
 pred_ls (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
-  (void) pred_ptr;
-  
-  list_file (pathname, state.rel_pathname, stat_buf, options.start_time,
-	     options.output_block_size, stdout);
-  return (true);
+  list_file (pathname, state.cwd_dir_fd, state.rel_pathname,
+	     stat_buf, options.start_time.tv_sec,
+	     options.output_block_size,
+	     pred_ptr->literal_control_chars,
+	     stdout);
+  return true;
 }
 
 boolean
 pred_mmin (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
   (void) &pathname;
-  return pred_timewindow(stat_buf->st_mtime, pred_ptr, 60);
+  return pred_timewindow(get_stat_mtime(stat_buf), pred_ptr, 60);
 }
 
 boolean
 pred_mtime (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
   (void) pathname;
-  return pred_timewindow(stat_buf->st_mtime, pred_ptr, DAYSECS);
+  return pred_timewindow(get_stat_mtime(stat_buf), pred_ptr, DAYSECS);
 }
 
 boolean
@@ -1027,7 +1196,7 @@ pred_negate (char *pathname, struct stat
 {
   /* Check whether we need a stat here. */
   /* TODO: what about need_type? */
-  if (get_info(pathname, state.rel_pathname, stat_buf, pred_ptr) != 0)
+  if (get_info(pathname, stat_buf, pred_ptr) != 0)
     return false;
   return (!(*pred_ptr->pred_right->pred_func) (pathname, stat_buf,
 					      pred_ptr->pred_right));
@@ -1038,9 +1207,44 @@ pred_newer (char *pathname, struct stat
 {
   (void) pathname;
   
-  if (stat_buf->st_mtime > pred_ptr->args.time)
-    return (true);
-  return (false);
+  assert(COMP_GT == pred_ptr->args.reftime.kind);
+  return compare_ts(get_stat_mtime(stat_buf), pred_ptr->args.reftime.ts) > 0;
+}
+
+boolean
+pred_newerXY (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
+{
+  struct timespec ts;
+  
+  assert(COMP_GT == pred_ptr->args.reftime.kind);
+  
+  switch (pred_ptr->args.reftime.xval)
+    {
+    case XVAL_ATIME:
+      ts = get_stat_atime(stat_buf);
+      break;
+    case XVAL_BIRTHTIME:
+      ts = get_stat_birthtime(stat_buf);
+      if (ts.tv_nsec < 0);
+	{
+	  /* XXX: Cannot determine birth time.  Warn once. */
+	  error(0, 0, _("Warning: cannot determine birth time of file `%s'"),
+		pathname);
+	  return 0;
+	}
+      break;
+    case XVAL_CTIME:
+      ts = get_stat_ctime(stat_buf);
+      break;
+    case XVAL_MTIME:
+      ts = get_stat_mtime(stat_buf);
+      break;
+    case XVAL_TIME:		/* Should not happen (-newertY is not valid). */
+      assert(pred_ptr->args.reftime.xval != XVAL_TIME);
+      abort();
+      break;
+    }
+  return compare_ts(ts, pred_ptr->args.reftime.ts) > 0;
 }
 
 boolean
@@ -1085,6 +1289,7 @@ is_ok(const char *program, const char *a
      The exact format is not specified.
      This standard does not have requirements for locales other than POSIX
   */
+  /* XXX: printing UNTRUSTED data here. */
   fprintf (stderr, _("< %s ... %s > ? "), program, arg);
   fflush (stderr);
   return yesno();
@@ -1094,7 +1299,8 @@ boolean
 pred_ok (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
   if (is_ok(pred_ptr->args.exec_vec.replace_vec[0], pathname))
-    return new_impl_pred_exec (pathname, stat_buf, pred_ptr, NULL, 0);
+    return new_impl_pred_exec (get_start_dirfd(),
+			       pathname, stat_buf, pred_ptr, NULL, 0);
   else
     return false;
 }
@@ -1104,7 +1310,8 @@ pred_okdir (char *pathname, struct stat
 {
   const char *prefix = (state.rel_pathname[0] == '/') ? NULL : "./";
   if (is_ok(pred_ptr->args.exec_vec.replace_vec[0], pathname))
-    return new_impl_pred_exec (state.rel_pathname, stat_buf, pred_ptr, 
+    return new_impl_pred_exec (get_current_dirfd(),
+			       state.rel_pathname, stat_buf, pred_ptr, 
 			       prefix, (prefix ? 2 : 0));
   else
     return false;
@@ -1126,7 +1333,7 @@ pred_or (char *pathname, struct stat *st
       || !(*pred_ptr->pred_left->pred_func) (pathname, stat_buf,
 					     pred_ptr->pred_left))
     {
-      if (get_info(pathname, state.rel_pathname, stat_buf, pred_ptr) != 0)
+      if (get_info(pathname, stat_buf, pred_ptr) != 0)
 	return false;
       return ((*pred_ptr->pred_right->pred_func) (pathname, stat_buf,
 						  pred_ptr->pred_right));
@@ -1147,19 +1354,34 @@ pred_path (char *pathname, struct stat *
 boolean
 pred_perm (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
+  mode_t mode = stat_buf->st_mode;
+  mode_t perm_val = pred_ptr->args.perm.val[S_ISDIR (mode) != 0];
   (void) pathname;
   switch (pred_ptr->args.perm.kind)
     {
     case PERM_AT_LEAST:
-      return (stat_buf->st_mode & pred_ptr->args.perm.val) == pred_ptr->args.perm.val;
+      return (mode & perm_val) == perm_val;
       break;
 
     case PERM_ANY:
-      return (stat_buf->st_mode & pred_ptr->args.perm.val) != 0;
+      /* True if any of the bits set in the mask are also set in the file's mode.
+       *
+       *
+       * Otherwise, if onum is prefixed by a hyphen, the primary shall
+       * evaluate as true if at least all of the bits specified in
+       * onum that are also set in the octal mask 07777 are set.
+       *
+       * Eric Blake's interpretation is that the mode argument is zero, 
+       
+       */
+      if (0 == perm_val)
+	return true;		/* Savannah bug 14748; we used to return false */
+      else
+	return (mode & perm_val) != 0;
       break;
 
     case PERM_EXACT:
-      return (stat_buf->st_mode & MODE_ALL) == pred_ptr->args.perm.val;
+      return (mode & MODE_ALL) == perm_val;
       break;
 
     default:
@@ -1168,12 +1390,76 @@ pred_perm (char *pathname, struct stat *
     }
 }
 
+
+struct access_check_args
+{
+  const char *filename;
+  int access_type;
+  int cb_errno;
+};
+
+
+static int
+access_callback(void *context)
+{
+  int rv;
+  struct access_check_args *args = context;
+  if ((rv = access(args->filename, args->access_type)) < 0)
+    args->cb_errno = errno;
+  return rv;
+}
+
+static int
+can_access(int access_type)
+{
+  struct access_check_args args;
+  args.filename = state.rel_pathname;
+  args.access_type = access_type;
+  args.cb_errno = 0;
+  return 0 == run_in_dir(state.cwd_dir_fd, access_callback, &args);
+}
+
+
+boolean
+pred_executable (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
+{
+  (void) pathname;
+  (void) stat_buf;
+  (void) pred_ptr;
+  
+  return can_access(X_OK);
+}
+
+boolean
+pred_readable (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
+{
+  (void) pathname;
+  (void) stat_buf;
+  (void) pred_ptr;
+  
+  return can_access(R_OK);
+}
+
+boolean
+pred_writable (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
+{
+  (void) pathname;
+  (void) stat_buf;
+  (void) pred_ptr;
+  
+  return can_access(W_OK);
+}
+
 boolean
 pred_print (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
   (void) stat_buf;
   (void) pred_ptr;
-  puts (pathname);
+  /* puts (pathname); */
+  print_quoted(pred_ptr->args.printf_vec.stream,
+	       pred_ptr->args.printf_vec.quote_opts,
+	       pred_ptr->args.printf_vec.dest_is_tty,
+	       "%s\n", pathname);
   return true;
 }
 
@@ -1191,9 +1477,13 @@ boolean
 pred_prune (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
   (void) pathname;
-  (void) stat_buf;
   (void) pred_ptr;
-  state.stop_at_current_level = true;
+
+  if (options.do_dir_first == true &&
+      stat_buf != NULL &&
+      S_ISDIR(stat_buf->st_mode))
+    state.stop_at_current_level = true;
+
   return (options.do_dir_first); /* This is what SunOS find seems to do. */
 }
 
@@ -1255,14 +1545,16 @@ pred_size (char *pathname, struct stat *
 boolean
 pred_samefile (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
-  /* Potential optimisation: because of the loop protection, we 
-   * always know the device of the current directory, hence the 
-   * device number of the current filesystem.  If -L is not in 
-   * effect, and the device number of the file we're looking for 
-   * is not the same as the device number of the current directory,
-   * this predicate cannot return true.   Hence there would be no 
-   * need to stat the file.
+  /* Potential optimisation: because of the loop protection, we always
+   * know the device of the current directory, hence the device number
+   * of the file we're currently considering.  If -L is not in effect,
+   * and the device number of the file we're looking for is not the
+   * same as the device number of the current directory, this
+   * predicate cannot return true.  Hence there would be no need to
+   * stat the file we're looking at.
    */
+  (void) pathname;
+  
   return stat_buf->st_ino == pred_ptr->args.fileid.ino
     &&   stat_buf->st_dev == pred_ptr->args.fileid.dev;
 }
@@ -1324,18 +1616,18 @@ boolean
 pred_uid (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
   (void) pathname;
-  switch (pred_ptr->args.info.kind)
+  switch (pred_ptr->args.numinfo.kind)
     {
     case COMP_GT:
-      if (stat_buf->st_uid > pred_ptr->args.info.l_val)
+      if (stat_buf->st_uid > pred_ptr->args.numinfo.l_val)
 	return (true);
       break;
     case COMP_LT:
-      if (stat_buf->st_uid < pred_ptr->args.info.l_val)
+      if (stat_buf->st_uid < pred_ptr->args.numinfo.l_val)
 	return (true);
       break;
     case COMP_EQ:
-      if (stat_buf->st_uid == pred_ptr->args.info.l_val)
+      if (stat_buf->st_uid == pred_ptr->args.numinfo.l_val)
 	return (true);
       break;
     }
@@ -1345,10 +1637,20 @@ pred_uid (char *pathname, struct stat *s
 boolean
 pred_used (char *pathname, struct stat *stat_buf, struct predicate *pred_ptr)
 {
-  time_t delta;
+  struct timespec delta, at, ct;
 
   (void) pathname;
-  delta = stat_buf->st_atime - stat_buf->st_ctime; /* Use difftime? */
+
+  /* TODO: this needs to be retested carefully (manually, if necessary) */
+  at = get_stat_atime(stat_buf);
+  ct = get_stat_ctime(stat_buf);
+  delta.tv_sec  = at.tv_sec  - ct.tv_sec;
+  delta.tv_nsec = at.tv_nsec - ct.tv_nsec;
+  if (delta.tv_nsec < 0)
+    {
+      delta.tv_nsec += 1000000000;
+      delta.tv_sec  -=          1;
+    }
   return pred_timewindow(delta, pred_ptr, DAYSECS);
 }
 
@@ -1376,6 +1678,7 @@ pred_xtype (char *pathname, struct stat
   else
     ystat = optionl_stat;
   
+  set_stat_placeholders(&sbuf);
   if ((*ystat) (state.rel_pathname, &sbuf) != 0)
     {
       if (following_links() && errno == ENOENT)
@@ -1418,22 +1721,52 @@ pred_xtype (char *pathname, struct stat
     Otherwise return false, possibly printing an error message. */
 
 
-static void
-prep_child_for_exec (void)
+static boolean
+prep_child_for_exec (boolean close_stdin, int dirfd)
 {
-  const char inputfile[] = "/dev/null";
-  /* fprintf(stderr, "attaching stdin to /dev/null\n"); */
-  
-  close(0);
-  if (open(inputfile, O_RDONLY) < 0)
+  boolean ok = true;
+  if (close_stdin)
     {
-      /* This is not entirely fatal, since 
-       * executing the child with a closed
-       * stdin is almost as good as executing it
-       * with its stdin attached to /dev/null.
-       */
-      error (0, errno, "%s", inputfile);
+      const char inputfile[] = "/dev/null";
+      
+      if (close(0) < 0)
+	{
+	  error(0, errno, _("Cannot close standard input"));
+	  ok = false;
+	}
+      else 
+	{
+	  if (open(inputfile, O_RDONLY|O_LARGEFILE) < 0)
+	    {
+	      /* This is not entirely fatal, since 
+	       * executing the child with a closed
+	       * stdin is almost as good as executing it
+	       * with its stdin attached to /dev/null.
+	       */
+	      error (0, errno, "%s", inputfile);
+	      /* do not set ok=false, it is OK to continue anyway. */
+	    }
+	}
+    }
+
+  /* Even if DebugSearch is set, don't announce our change of
+   * directory, since we're not going to emit a subsequent
+   * announcement of a call to stat() anyway, as we're about to exec
+   * something.
+   */
+  if (dirfd != AT_FDCWD)
+    {
+      assert(dirfd >= 0);
+      if (0 != fchdir(dirfd))
+	{
+	  /* If we cannot execute our command in the correct directory,
+	   * we should not execute it at all.
+	   */
+	  error(0, errno, _("Failed to change directory"));
+	  ok = false;
+	}
     }
+  return ok;
 }
 
 
@@ -1446,7 +1779,14 @@ launch (const struct buildcmd_control *c
   pid_t child_pid;
   static int first_time = 1;
   const struct exec_val *execp = buildstate->usercontext;
+
+  if (!execp->use_current_dir)
+    {
+      assert(starting_desc >= 0);
+      assert(execp->dirfd == starting_desc);
+    }
   
+	
   /* Null terminate the arg list.  */
   bc_push_arg (ctl, buildstate, (char *) NULL, 0, NULL, 0, false); 
   
@@ -1466,27 +1806,11 @@ launch (const struct buildcmd_control *c
     error (1, errno, _("cannot fork"));
   if (child_pid == 0)
     {
-      /* We be the child. */
-      prep_child_for_exec();
-
-      /* For -exec and -ok, change directory back to the starting directory.
-       * for -execdir and -okdir, stay in the directory we are searching
-       * (the latter is more secure).
-       */
-      if (!execp->use_current_dir)
+      /* We are the child. */
+      assert(starting_desc >= 0);
+      if (!prep_child_for_exec(execp->close_stdin, execp->dirfd))
 	{
-	  /* Even if DEBUG_STAT is set, don't announce our change of 
-	   * directory, since we're not going to emit a subsequent 
-	   * announcement of a call to stat() anyway, as we're about 
-	   * to exec something. 
-	   */
-	  if (starting_desc < 0
-	      ? chdir (starting_dir) != 0
-	      : fchdir (starting_desc) != 0)
-	    {
-	      error (0, errno, "%s", starting_dir);
-	      _exit (1);
-	    }
+	  _exit(1);
 	}
       
       execvp (buildstate->cmd_argv[0], buildstate->cmd_argv);
@@ -1547,139 +1871,196 @@ launch (const struct buildcmd_control *c
 
 
 /* Return a static string formatting the time WHEN according to the
-   strftime format character KIND.  */
-
+ * strftime format character KIND.
+ *
+ * This function contains a number of assertions.  These look like
+ * runtime checks of the results of computations, which would be a
+ * problem since external events should not be tested for with
+ * "assert" (instead you should use "if").  However, they are not
+ * really runtime checks.  The assertions actually exist to verify
+ * that the various buffers are correctly sized.
+ */
 static char *
-format_date (time_t when, int kind)
+format_date (struct timespec ts, int kind)
 {
-  static char buf[MAX (LONGEST_HUMAN_READABLE + 2, 64)];
+  /* In theory, we use an extra 10 characters for 9 digits of
+   * nanoseconds and 1 for the decimal point.  However, the real
+   * world is more complex than that.
+   *
+   * For example, some systems return junk in the tv_nsec part of
+   * st_birthtime.  An example of this is the NetBSD-4.0-RELENG kernel
+   * (at Sat Mar 24 18:46:46 2007) running a NetBSD-3.1-RELEASE
+   * runtime and examining files on an msdos filesytem.  So for that 
+   * reason we set NS_BUF_LEN to 32, which is simply "long enough" as 
+   * opposed to "exactly the right size".  Note that the behaviour of 
+   * NetBSD appears to be a result of the use of uninitialised data, 
+   * as it's not 100% reproducible (more like 25%).
+   */
+  enum {
+    NS_BUF_LEN = 32,
+    DATE_LEN_PERCENT_APLUS=21	/* length of result of %A+ (it's longer than %c)*/
+  };	  
+  static char buf[128u+10u + MAX(DATE_LEN_PERCENT_APLUS,
+			    MAX (LONGEST_HUMAN_READABLE + 2, NS_BUF_LEN+64+200))];
+  char ns_buf[NS_BUF_LEN]; /* -.9999999990 (- sign can happen!)*/
+  int  charsprinted, need_ns_suffix;
   struct tm *tm;
   char fmt[6];
 
-  fmt[0] = '%';
-  fmt[1] = kind;
-  fmt[2] = '\0';
+  /* human_readable() assumes we pass a buffer which is at least as
+   * long as LONGEST_HUMAN_READABLE.  We use an assertion here to
+   * ensure that no nasty unsigned overflow happend in our calculation
+   * of the size of buf.  Do the assertion here rather than in the
+   * code for %@ so that we find the problem quickly if it exists.  If
+   * you want to submit a patch to move this into the if statement, go
+   * ahead, I'll apply it.  But include performance timings
+   * demonstrating that the performance difference is actually
+   * measurable.
+   */
+  assert(sizeof(buf) >= LONGEST_HUMAN_READABLE);
+  
+  /* Format the main part of the time. */
   if (kind == '+')
-    strcpy (fmt, "%F+%T");
-
-  if (kind != '@'
-      && (tm = localtime (&when))
-      && strftime (buf, sizeof buf, fmt, tm))
-    return buf;
+    {
+      strcpy (fmt, "%F+%T");
+      need_ns_suffix = 1;
+    }
   else
     {
-      uintmax_t w = when;
-      char *p = human_readable (when < 0 ? -w : w, buf + 1,
-				human_ceiling, 1, 1);
-      if (when < 0)
-	*--p = '-';
-      return p;
+      fmt[0] = '%';
+      fmt[1] = kind;
+      fmt[2] = '\0';
+
+      /* %a, %c, and %t are handled in ctime_format() */
+      switch (kind)
+	{
+	case 'S':
+	case 'T':
+	case 'X':
+	case '@':
+	  need_ns_suffix = 1;
+	  break;
+	default:
+	  need_ns_suffix = 0;
+	  break;
+	}
     }
-}
 
-static char *
-ctime_format (when)
-     time_t when;
-{
-  char *r = ctime (&when);
-  if (!r)
+  if (need_ns_suffix)
     {
-      /* The time cannot be represented as a struct tm.
-	 Output it as an integer.  */
-      return format_date (when, '@');
+      /* Format the nanoseconds part.  Leave a trailing zero to discourage people from 
+       * writing scripts which extract the fractional part of the timestamp by using 
+       * column offsets.  The reason for discouraging this is that in the future, the 
+       * granularity may not be nanoseconds.
+       */
+      ns_buf[0] = 0;
+      charsprinted = snprintf(ns_buf, NS_BUF_LEN, ".%09ld0", (long int)ts.tv_nsec);
+      assert(charsprinted < NS_BUF_LEN);
     }
-  else
+
+  if (kind != '@'
+      && (tm = localtime (&ts.tv_sec))
+      && strftime (buf, sizeof buf, fmt, tm))
     {
-      /* Remove the trailing newline from the ctime output,
-	 being careful not to assume that the output is fixed-width.  */
-      *strchr (r, '\n') = '\0';
-      return r;
+      /* For %AS, %CS, %TS, add the fractional part of the seconds information. */
+      if (need_ns_suffix)
+	{
+	  assert((sizeof buf - strlen(buf)) > strlen(ns_buf));
+	  strcat(buf, ns_buf);
+	}
+      return buf;
     }
-}
-
-#ifdef	DEBUG
-/* Return a pointer to the string representation of 
-   the predicate function PRED_FUNC. */
-
-char *
-find_pred_name (pred_func)
-     PFB pred_func;
-{
-  int i;
+  else
+    {
+      uintmax_t w = ts.tv_sec;
+      size_t used, len, remaining;
 
-  for (i = 0; pred_table[i].pred_func != 0; i++)
-    if (pred_table[i].pred_func == pred_func)
-      break;
-  return (pred_table[i].pred_name);
+      /* XXX: note that we are negating an unsigned type which is the
+       * widest possible unsigned type.
+       */
+      char *p = human_readable (ts.tv_sec < 0 ? -w : w, buf + 1,
+				human_ceiling, 1, 1);
+      assert(p > buf);
+      assert(p < (buf + (sizeof buf)));
+      if (ts.tv_sec < 0)
+	*--p = '-'; /* XXX: Ugh, relying on internal details of human_readable(). */
+
+      /* Add the nanoseconds part.  Because we cannot enforce a particlar implementation 
+       * of human_readable, we cannot assume any particular value for (p-buf).  So we 
+       * need to be careful that there is enough space remaining in the buffer.
+       */
+      if (need_ns_suffix)
+	{
+	  len = strlen(p);
+	  used = (p-buf) + len;	/* Offset into buf of current end */
+	  assert(sizeof buf > used); /* Ensure we can perform subtraction safely. */
+	  remaining = sizeof buf - used - 1u; /* allow space for NUL */
+	  
+	  if (strlen(ns_buf) >= remaining)
+	    {
+	      error(0, 0,
+		    "charsprinted=%ld but remaining=%lu: ns_buf=%s",
+		    (long)charsprinted, (unsigned long)remaining, ns_buf);
+	    }
+	  assert(strlen(ns_buf) < remaining);
+	  strcat(p, ns_buf);
+	}
+      return p;
+    }
 }
 
-static char *
-type_name (type)
-     short type;
-{
-  int i;
+static const char *weekdays[] = 
+  {
+    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
+  };
+static char * months[] = 
+  {
+    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
+    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+  };
 
-  for (i = 0; type_table[i].type != (short) -1; i++)
-    if (type_table[i].type == type)
-      break;
-  return (type_table[i].type_name);
-}
 
 static char *
-prec_name (prec)
-     short prec;
+ctime_format (struct timespec ts)
 {
-  int i;
-
-  for (i = 0; prec_table[i].prec != (short) -1; i++)
-    if (prec_table[i].prec == prec)
-      break;
-  return (prec_table[i].prec_name);
-}
-
-/* Walk the expression tree NODE to stdout.
-   INDENT is the number of levels to indent the left margin. */
-
-void
-print_tree (FILE *fp, struct predicate *node, int indent)
-{
-  int i;
-
-  if (node == NULL)
-    return;
-  for (i = 0; i < indent; i++)
-    fprintf (fp, "    ");
-  fprintf (fp, "pred = %s type = %s prec = %s addr = %p\n",
-	  find_pred_name (node->pred_func),
-	  type_name (node->p_type), prec_name (node->p_prec), node);
-  if (node->need_stat || node->need_type)
-    {
-      int comma = 0;
+  const struct tm * ptm;
+#define TIME_BUF_LEN 1024u
+  static char resultbuf[TIME_BUF_LEN];
+  int nout;
+  
+  ptm = localtime(&ts.tv_sec);
+  if (ptm)
+    {
+      assert(ptm->tm_wday >=  0);
+      assert(ptm->tm_wday <   7);
+      assert(ptm->tm_mon  >=  0);
+      assert(ptm->tm_mon  <  12);
+      assert(ptm->tm_hour >=  0);
+      assert(ptm->tm_hour <  24);
+      assert(ptm->tm_min  <  60);
+      assert(ptm->tm_sec  <= 61); /* allows 2 leap seconds. */
       
-      for (i = 0; i < indent; i++)
-	fprintf (fp, "    ");
+      /* wkday mon mday hh:mm:ss.nnnnnnnnn yyyy */
+      nout = snprintf(resultbuf, TIME_BUF_LEN,
+		      "%3s %3s %2d %02d:%02d:%02d.%010ld %04d",
+		      weekdays[ptm->tm_wday],
+		      months[ptm->tm_mon],
+		      ptm->tm_mday,
+		      ptm->tm_hour,
+		      ptm->tm_min,
+		      ptm->tm_sec,
+		      (long int)ts.tv_nsec,
+		      1900 + ptm->tm_year);
       
-      fprintf (fp, "Needs ");
-      if (node->need_stat)
-	{
-	  fprintf (fp, "stat");
-	  comma = 1;
-	}
-      if (node->need_type)
-	{
-	  fprintf (fp, "%stype", comma ? "," : "");
-	}
-      fprintf (fp, "\n");
+      assert(nout < TIME_BUF_LEN);
+      return resultbuf;
+    }
+  else
+    {
+      /* The time cannot be represented as a struct tm.
+	 Output it as an integer.  */
+      return format_date (ts, '@');
     }
-  
-  for (i = 0; i < indent; i++)
-    fprintf (fp, "    ");
-  fprintf (fp, _("left:\n"));
-  print_tree (fp, node->pred_left, indent + 1);
-  for (i = 0; i < indent; i++)
-    fprintf (fp, "    ");
-  fprintf (fp, _("right:\n"));
-  print_tree (fp, node->pred_right, indent + 1);
 }
 
 /* Copy STR into BUF and trim blanks from the end of BUF.
@@ -1703,7 +2084,6 @@ blank_rtrim (str, buf)
 }
 
 /* Print out the predicate list starting at NODE. */
-
 void
 print_list (FILE *fp, struct predicate *node)
 {
@@ -1713,16 +2093,13 @@ print_list (FILE *fp, struct predicate *
   cur = node;
   while (cur != NULL)
     {
-      fprintf (fp, "%s ", blank_rtrim (find_pred_name (cur->pred_func), name));
+      fprintf (fp, "%s ", blank_rtrim (cur->p_name, name));
       cur = cur->pred_next;
     }
   fprintf (fp, "\n");
 }
-
 
 /* Print out the predicate list starting at NODE. */
-
-
 static void
 print_parenthesised(FILE *fp, struct predicate *node)
 {
@@ -1752,22 +2129,96 @@ print_parenthesised(FILE *fp, struct pre
 	}
     }
 }
-
+
 void
-print_optlist (FILE *fp, struct predicate *p)
+print_optlist (FILE *fp, const struct predicate *p)
 {
-  char name[256];
-
   if (p)
     {
       print_parenthesised(fp, p->pred_left);
       fprintf (fp,
-	       "%s%s%s ",
-	       p->need_stat ? _("[stat called here] ") : "",
-	       p->need_type ? _("[type needed here] ") : "",
-	       blank_rtrim (find_pred_name (p->pred_func), name));
+	       "%s%s",
+	       p->need_stat ? "[call stat] " : "",
+	       p->need_type ? "[need type] " : "");
+      print_predicate(fp, p);
+      fprintf(fp, " [%g] ", p->est_success_rate);
       print_parenthesised(fp, p->pred_right);
     }
 }
+
+#ifdef _NDEBUG
+/* If _NDEBUG is defined, the assertions will do nothing.   Hence 
+ * there is no point in having a function body for pred_sanity_check()
+ * if that preprocessor macro is defined. 
+ */
+void
+pred_sanity_check(const struct predicate *predicates)
+{
+  /* Do nothing, since assert() is a no-op with _NDEBUG set */
+  return;
+}
+#else
+void
+pred_sanity_check(const struct predicate *predicates)
+{
+  const struct predicate *p;
+  
+  for (p=predicates; p != NULL; p=p->pred_next)
+    {
+      /* All predicates must do something. */
+      assert(p->pred_func != NULL);
 
-#endif	/* DEBUG */
+      /* All predicates must have a parser table entry. */
+      assert(p->parser_entry != NULL);
+      
+      /* If the parser table tells us that just one predicate function is 
+       * possible, verify that that is still the one that is in effect.
+       * If the parser has NULL for the predicate function, that means that 
+       * the parse_xxx function fills it in, so we can't check it.
+       */
+      if (p->parser_entry->pred_func)
+	{
+	  assert(p->parser_entry->pred_func == p->pred_func);
+	}
+      
+      switch (p->parser_entry->type)
+	{
+	  /* Options all take effect during parsing, so there should
+	   * be no predicate entries corresponding to them.  Hence we
+	   * should not see any ARG_OPTION or ARG_POSITIONAL_OPTION
+	   * items.
+	   *
+	   * This is a silly way of coding this test, but it prevents
+	   * a compiler warning (i.e. otherwise it would think that
+	   * there would be case statements missing).
+	   */
+	case ARG_OPTION:
+	case ARG_POSITIONAL_OPTION:
+	  assert(p->parser_entry->type != ARG_OPTION);
+	  assert(p->parser_entry->type != ARG_POSITIONAL_OPTION);
+	  break;
+	  
+	case ARG_ACTION:
+	  assert(p->side_effects); /* actions have side effects. */
+	  if (p->pred_func != pred_prune && p->pred_func != pred_quit)
+	    {
+	      /* actions other than -prune and -quit should
+	       * inhibit the default -print
+	       */
+	      assert(p->no_default_print);
+	    }
+	  break;
+
+	case ARG_PUNCTUATION:
+	case ARG_TEST:
+	case ARG_NOOP:
+	  /* Punctuation and tests should have no side
+	   * effects and not inhibit default print.
+	   */
+	  assert(!p->no_default_print);
+	  assert(!p->side_effects);
+	  break;
+	}
+    }
+}
+#endif
Binary files dbg/find14/find/find/pred.o and dbg/find6/find/find/pred.o differ
diff -up -r dbg/find14/find/find/testsuite/config/unix.exp dbg/find6/find/find/testsuite/config/unix.exp
