--- dbg/find14/find/gnulib-cvs/gnulib/lib/openat.c	2020-01-28 23:47:42.000000000 -0600
+++ dbg/find6/find/gnulib-cvs/gnulib/lib/openat.c	2020-01-28 23:39:42.000000000 -0600
@@ -1,5 +1,5 @@
 /* provide a replacement openat function
-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.
+   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -13,7 +13,7 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software Foundation,
-   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
 
 /* written by Jim Meyering */
 
@@ -21,33 +21,27 @@
 
 #include "openat.h"
 
-#include <stdlib.h>
 #include <stdarg.h>
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
+#include <stddef.h>
 
-#include "error.h"
-#include "exitfail.h"
+#include "dirname.h" /* solely for definition of IS_ABSOLUTE_FILE_NAME */
+#include "fcntl--.h"
+#include "lchown.h"
+#include "lstat.h"
+#include "openat-priv.h"
 #include "save-cwd.h"
 
-#include "gettext.h"
-#define _(msgid) gettext (msgid)
-
 /* Replacement for Solaris' openat function.
    <http://www.google.com/search?q=openat+site:docs.sun.com>
-   Simulate it by doing save_cwd/fchdir/open/restore_cwd.
-   If either the save_cwd or the restore_cwd fails (relatively unlikely,
-   and usually indicative of a problem that deserves close attention),
+   First, try to simulate it via open ("/proc/self/fd/FD/FILE").
+   Failing that, simulate it by doing save_cwd/fchdir/open/restore_cwd.
+   If either the save_cwd or the restore_cwd fails (relatively unlikely),
    then give a diagnostic and exit nonzero.
    Otherwise, upon failure, set errno and return -1, as openat does.
    Upon successful completion, return a file descriptor.  */
 int
-rpl_openat (int fd, char const *filename, int flags, ...)
+openat (int fd, char const *file, int flags, ...)
 {
-  struct saved_cwd saved_cwd;
-  int saved_errno;
-  int new_fd;
   mode_t mode = 0;
 
   if (flags & O_CREAT)
@@ -55,48 +49,128 @@ rpl_openat (int fd, char const *filename
       va_list arg;
       va_start (arg, flags);
 
-      /* Assume that mode_t is passed compatibly with mode_t's type
-	 after argument promotion.  */
-      mode = va_arg (arg, mode_t);
+      /* If mode_t is narrower than int, use the promoted type (int),
+         not mode_t.  Use sizeof to guess whether mode_t is narrower;
+         we don't know of any practical counterexamples.  */
+      mode = (sizeof (mode_t) < sizeof (int)
+	      ? va_arg (arg, int)
+	      : va_arg (arg, mode_t));
 
       va_end (arg);
     }
 
-  if (fd == AT_FDCWD || *filename == '/')
-    return open (filename, flags, mode);
+  return openat_permissive (fd, file, flags, mode, NULL);
+}
 
-  if (save_cwd (&saved_cwd) != 0)
-    error (exit_failure, errno,
-	   _("openat: unable to record current working directory"));
+/* Like openat (FD, FILE, FLAGS, MODE), but if CWD_ERRNO is
+   nonnull, set *CWD_ERRNO to an errno value if unable to save
+   or restore the initial working directory.  This is needed only
+   the first time remove.c's remove_dir opens a command-line
+   directory argument.
+
+   If a previous attempt to restore the current working directory
+   failed, then we must not even try to access a `.'-relative name.
+   It is the caller's responsibility not to call this function
+   in that case.  */
 
-  if (fchdir (fd) != 0)
+int
+openat_permissive (int fd, char const *file, int flags, mode_t mode,
+		   int *cwd_errno)
+{
+  struct saved_cwd saved_cwd;
+  int saved_errno;
+  int err;
+  bool save_ok;
+
+  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))
+    return open (file, flags, mode);
+
+  {
+    char buf[OPENAT_BUFFER_SIZE];
+    char *proc_file = openat_proc_name (buf, fd, file);
+    if (proc_file)
+      {
+	int open_result = open (proc_file, flags, mode);
+	int open_errno = errno;
+	if (proc_file != buf)
+	  free (proc_file);
+	/* If the syscall succeeds, or if it fails with an unexpected
+	   errno value, then return right away.  Otherwise, fall through
+	   and resort to using save_cwd/restore_cwd.  */
+	if (0 <= open_result || ! EXPECTED_ERRNO (open_errno))
+	  {
+	    errno = open_errno;
+	    return open_result;
+	  }
+      }
+  }
+
+  save_ok = (save_cwd (&saved_cwd) == 0);
+  if (! save_ok)
     {
-      saved_errno = errno;
-      free_cwd (&saved_cwd);
-      errno = saved_errno;
-      return -1;
+      if (! cwd_errno)
+	openat_save_fail (errno);
+      *cwd_errno = errno;
     }
 
-  new_fd = open (filename, flags, mode);
+  err = fchdir (fd);
   saved_errno = errno;
 
-  if (restore_cwd (&saved_cwd) != 0)
-    error (exit_failure, errno,
-	   _("openat: unable to restore working directory"));
+  if (! err)
+    {
+      err = open (file, flags, mode);
+      saved_errno = errno;
+      if (save_ok && restore_cwd (&saved_cwd) != 0)
+	{
+	  if (! cwd_errno)
+	    openat_restore_fail (errno);
+	  *cwd_errno = errno;
+	}
+    }
 
   free_cwd (&saved_cwd);
-
   errno = saved_errno;
-  return new_fd;
+  return err;
+}
+
+/* Return true if our openat implementation must resort to
+   using save_cwd and restore_cwd.  */
+bool
+openat_needs_fchdir (void)
+{
+  bool needs_fchdir = true;
+  int fd = open ("/", O_RDONLY);
+
+  if (0 <= fd)
+    {
+      char buf[OPENAT_BUFFER_SIZE];
+      char *proc_file = openat_proc_name (buf, fd, ".");
+      if (proc_file)
+	{
+	  needs_fchdir = false;
+	  if (proc_file != buf)
+	    free (proc_file);
+	}
+      close (fd);
+    }
+
+  return needs_fchdir;
 }
 
+#if !HAVE_FDOPENDIR
+
 /* Replacement for Solaris' function by the same name.
    <http://www.google.com/search?q=fdopendir+site:docs.sun.com>
-   Simulate it by doing save_cwd/fchdir/opendir(".")/restore_cwd.
-   If either the save_cwd or the restore_cwd fails (relatively unlikely,
-   and usually indicative of a problem that deserves close attention),
+   First, try to simulate it via opendir ("/proc/self/fd/FD").  Failing
+   that, simulate it by doing save_cwd/fchdir/opendir(".")/restore_cwd.
+   If either the save_cwd or the restore_cwd fails (relatively unlikely),
    then give a diagnostic and exit nonzero.
-   Otherwise, this function works just like Solaris' fdopendir.  */
+   Otherwise, this function works just like Solaris' fdopendir.
+
+   W A R N I N G:
+   Unlike the other fd-related functions here, this one
+   effectively consumes its FD parameter.  The caller should not
+   close or otherwise manipulate FD if this function returns successfully.  */
 DIR *
 fdopendir (int fd)
 {
@@ -104,76 +178,93 @@ fdopendir (int fd)
   int saved_errno;
   DIR *dir;
 
-  if (fd == AT_FDCWD)
-    return opendir (".");
-
-  if (save_cwd (&saved_cwd) != 0)
-    error (exit_failure, errno,
-	   _("fdopendir: unable to record current working directory"));
-
-  if (fchdir (fd) != 0)
+  char buf[OPENAT_BUFFER_SIZE];
+  char *proc_file = openat_proc_name (buf, fd, ".");
+  if (proc_file)
     {
+      dir = opendir (proc_file);
       saved_errno = errno;
-      free_cwd (&saved_cwd);
-      errno = saved_errno;
-      return NULL;
+    }
+  else
+    {
+      dir = NULL;
+      saved_errno = EOPNOTSUPP;
     }
 
-  dir = opendir (".");
-  saved_errno = errno;
+  /* If the syscall fails with an expected errno value, resort to
+     save_cwd/restore_cwd.  */
+  if (! dir && EXPECTED_ERRNO (saved_errno))
+    {
+      if (save_cwd (&saved_cwd) != 0)
+	openat_save_fail (errno);
 
-  if (restore_cwd (&saved_cwd) != 0)
-    error (exit_failure, errno,
-	   _("fdopendir: unable to restore working directory"));
+      if (fchdir (fd) != 0)
+	{
+	  dir = NULL;
+	  saved_errno = errno;
+	}
+      else
+	{
+	  dir = opendir (".");
+	  saved_errno = errno;
+
+	  if (restore_cwd (&saved_cwd) != 0)
+	    openat_restore_fail (errno);
+	}
 
-  free_cwd (&saved_cwd);
+      free_cwd (&saved_cwd);
+    }
 
+  if (dir)
+    close (fd);
+  if (proc_file != buf)
+    free (proc_file);
   errno = saved_errno;
   return dir;
 }
 
+#endif
+
 /* Replacement for Solaris' function by the same name.
    <http://www.google.com/search?q=fstatat+site:docs.sun.com>
-   Simulate it by doing save_cwd/fchdir/(stat|lstat)/restore_cwd.
-   If either the save_cwd or the restore_cwd fails (relatively unlikely,
-   and usually indicative of a problem that deserves close attention),
+   First, try to simulate it via l?stat ("/proc/self/fd/FD/FILE").
+   Failing that, simulate it via save_cwd/fchdir/(stat|lstat)/restore_cwd.
+   If either the save_cwd or the restore_cwd fails (relatively unlikely),
    then give a diagnostic and exit nonzero.
    Otherwise, this function works just like Solaris' fstatat.  */
-int
-fstatat (int fd, char const *filename, struct stat *st, int flag)
-{
-  struct saved_cwd saved_cwd;
-  int saved_errno;
-  int err;
 
-  if (fd == AT_FDCWD)
-    return (flag == AT_SYMLINK_NOFOLLOW
-	    ? lstat (filename, st)
-	    : stat (filename, st));
-
-  if (save_cwd (&saved_cwd) != 0)
-    error (exit_failure, errno,
-	   _("fstatat: unable to record current working directory"));
+#define AT_FUNC_NAME fstatat
+#define AT_FUNC_F1 lstat
+#define AT_FUNC_F2 stat
+#define AT_FUNC_USE_F1_COND flag == AT_SYMLINK_NOFOLLOW
+#define AT_FUNC_POST_FILE_PARAM_DECLS , struct stat *st, int flag
+#define AT_FUNC_POST_FILE_ARGS        , st
+#include "at-func.c"
+#undef AT_FUNC_NAME
+#undef AT_FUNC_F1
+#undef AT_FUNC_F2
+#undef AT_FUNC_USE_F1_COND
+#undef AT_FUNC_POST_FILE_PARAM_DECLS
+#undef AT_FUNC_POST_FILE_ARGS
 
-  if (fchdir (fd) != 0)
-    {
-      saved_errno = errno;
-      free_cwd (&saved_cwd);
-      errno = saved_errno;
-      return -1;
-    }
-
-  err = (flag == AT_SYMLINK_NOFOLLOW
-	 ? lstat (filename, st)
-	 : stat (filename, st));
-  saved_errno = errno;
-
-  if (restore_cwd (&saved_cwd) != 0)
-    error (exit_failure, errno,
-	   _("fstatat: unable to restore working directory"));
-
-  free_cwd (&saved_cwd);
+/* Replacement for Solaris' function by the same name.
+   <http://www.google.com/search?q=unlinkat+site:docs.sun.com>
+   First, try to simulate it via (unlink|rmdir) ("/proc/self/fd/FD/FILE").
+   Failing that, simulate it via save_cwd/fchdir/(unlink|rmdir)/restore_cwd.
+   If either the save_cwd or the restore_cwd fails (relatively unlikely),
+   then give a diagnostic and exit nonzero.
+   Otherwise, this function works just like Solaris' unlinkat.  */
 
-  errno = saved_errno;
-  return err;
-}
+#define AT_FUNC_NAME unlinkat
+#define AT_FUNC_F1 rmdir
+#define AT_FUNC_F2 unlink
+#define AT_FUNC_USE_F1_COND flag == AT_REMOVEDIR
+#define AT_FUNC_POST_FILE_PARAM_DECLS , int flag
+#define AT_FUNC_POST_FILE_ARGS        /* empty */
+#include "at-func.c"
+#undef AT_FUNC_NAME
+#undef AT_FUNC_F1
+#undef AT_FUNC_F2
+#undef AT_FUNC_USE_F1_COND
+#undef AT_FUNC_POST_FILE_PARAM_DECLS
+#undef AT_FUNC_POST_FILE_ARGS
Only in dbg/find6/find/gnulib-cvs/gnulib/lib: openat-die.c
diff -up -r dbg/find14/find/gnulib-cvs/gnulib/lib/openat.h dbg/find6/find/gnulib-cvs/gnulib/lib/openat.h
