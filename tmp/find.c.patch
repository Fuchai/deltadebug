--- dbg/find14/find/find/find.c	2020-01-28 23:47:42.000000000 -0600
+++ dbg/find6/find/find/find.c	2020-01-28 23:39:42.000000000 -0600
@@ -1,5 +1,6 @@
 /* find -- search for files in a directory hierarchy
-   Copyright (C) 1990, 91, 92, 93, 94, 2000, 2003, 2004 Free Software Foundation, Inc.
+   Copyright (C) 1990, 91, 92, 93, 94, 2000, 
+                 2003, 2004, 2005 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -13,7 +14,7 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
    USA.*/
 
 /* GNU find was written by Eric Decker <cire@cisco.com>,
@@ -21,12 +22,16 @@
    Jay Plett <jay@silence.princeton.nj.us>,
    and Tim Wood <axolotl!tim@toad.com>.
    The idea for -print0 and xargs -0 came from
-   Dan Bernstein <brnstnd@kramden.acf.nyu.edu>.  */
+   Dan Bernstein <brnstnd@kramden.acf.nyu.edu>.  
+   Improvements have been made by James Youngman <jay@gnu.org>.
+*/
 
 
 #include "defs.h"
 
 #define USE_SAFE_CHDIR 1
+#undef  STAT_MOUNTPOINTS
+
 
 #include <errno.h>
 #include <assert.h>
@@ -37,19 +42,19 @@
 #else
 #include <sys/file.h>
 #endif
-
-#ifdef HAVE_SYS_UTSNAME_H
-#include <sys/utsname.h>
-#endif
+#include <openat.h>
 
 #include "../gnulib/lib/xalloc.h"
 #include "../gnulib/lib/human.h"
 #include "../gnulib/lib/canonicalize.h"
-#include "closeout.h"
 #include <modetype.h>
+
+#include "closeout.h"
 #include "savedirinfo.h"
 #include "buildcmd.h"
 #include "dirname.h"
+#include "quote.h"
+#include "quotearg.h"
 
 #ifdef HAVE_LOCALE_H
 #include <locale.h>
@@ -73,46 +78,26 @@
 #define apply_predicate(pathname, stat_buf_ptr, node)	\
   (*(node)->pred_func)((pathname), (stat_buf_ptr), (node))
 
+#ifdef STAT_MOUNTPOINTS
+static void init_mounted_dev_list(int mandatory);
+#endif
 
-static void init_mounted_dev_list(void);
 static void process_top_path PARAMS((char *pathname, mode_t mode));
 static int process_path PARAMS((char *pathname, char *name, boolean leaf, char *parent, mode_t type));
 static void process_dir PARAMS((char *pathname, char *name, int pathlen, struct stat *statp, char *parent));
 
-static void complete_pending_execdirs(struct predicate *p);
-static void complete_pending_execs   (struct predicate *p);
 
 
-
-static boolean default_prints PARAMS((struct predicate *pred));
-
 /* Name this program was run with. */
 char *program_name;
 
-/* All predicates for each path to process. */
-struct predicate *predicates;
-
-/* The last predicate allocated. */
-struct predicate *last_pred;
-
-/* The root of the evaluation tree. */
-static struct predicate *eval_tree = NULL;
-
-
-struct options options;
-struct state state;
-
-/* The full path of the initial working directory, or "." if
-   STARTING_DESC is nonnegative.  */
-char const *starting_dir = ".";
-
 /* A file descriptor open to the initial working directory.
    Doing it this way allows us to work when the i.w.d. has
    unreadable parents.  */
 int starting_desc;
 
 /* The stat buffer of the initial working directory. */
-struct stat starting_stat_buf;
+static struct stat starting_stat_buf;
 
 enum ChdirSymlinkHandling
   {
@@ -127,258 +112,35 @@ enum TraversalDirection
     TraversingDown
   };
 
-
-int
-following_links(void)
-{
-  switch (options.symlink_handling)
-    {
-    case SYMLINK_ALWAYS_DEREF:
-      return 1;
-    case SYMLINK_DEREF_ARGSONLY:
-      return (state.curdepth == 0);
-    case SYMLINK_NEVER_DEREF:
-    default:
-      return 0;
-    }
-}
-
-
-static int
-fallback_stat(const char *name, struct stat *p, int prev_rv)
-{
-  /* Our original stat() call failed.  Perhaps we can't follow a
-   * symbolic link.  If that might be the problem, lstat() the link. 
-   * Otherwise, admit defeat. 
-   */
-  switch (errno)
-    {
-    case ENOENT:
-    case ENOTDIR:
-#ifdef DEBUG_STAT
-      fprintf(stderr, "fallback_stat(): stat(%s) failed; falling back on lstat()\n", name);
-#endif
-      return lstat(name, p);
-
-    case EACCES:
-    case EIO:
-    case ELOOP:
-    case ENAMETOOLONG:
-#ifdef EOVERFLOW
-    case EOVERFLOW:	    /* EOVERFLOW is not #defined on UNICOS. */
-#endif
-    default:
-      return prev_rv;	       
-    }
-}
-
-
-/* optionh_stat() implements the stat operation when the -H option is
- * in effect.
- * 
- * If the item to be examined is a command-line argument, we follow
- * symbolic links.  If the stat() call fails on the command-line item,
- * we fall back on the properties of the symbolic link.
- *
- * If the item to be examined is not a command-line argument, we
- * examine the link itself.
- */
-int 
-optionh_stat(const char *name, struct stat *p)
-{
-  if (0 == state.curdepth) 
-    {
-      /* This file is from the command line; deference the link (if it
-       * is a link).  
-       */
-      int rv = stat(name, p);
-      if (0 == rv)
-	return 0;		/* success */
-      else
-	return fallback_stat(name, p, rv);
-    }
-  else
-    {
-      /* Not a file on the command line; do not derefernce the link.
-       */
-      return lstat(name, p);
-    }
-}
-
-/* optionl_stat() implements the stat operation when the -L option is
- * in effect.  That option makes us examine the thing the symbolic
- * link points to, not the symbolic link itself.
- */
-int 
-optionl_stat(const char *name, struct stat *p)
-{
-  int rv = stat(name, p);
-  if (0 == rv)
-    return 0;			/* normal case. */
-  else
-    return fallback_stat(name, p, rv);
-}
-
-/* optionp_stat() implements the stat operation when the -P option is
- * in effect (this is also the default).  That option makes us examine
- * the symbolic link itself, not the thing it points to.
- */
-int 
-optionp_stat(const char *name, struct stat *p)
-{
-  return lstat(name, p);
-}
-
-#ifdef DEBUG_STAT
-static uintmax_t stat_count = 0u;
-
-static int
-debug_stat (const char *file, struct stat *bufp)
-{
-  ++stat_count;
-  fprintf (stderr, "debug_stat (%s)\n", file);
-  switch (options.symlink_handling)
-    {
-    case SYMLINK_ALWAYS_DEREF:
-      return optionl_stat(file, bufp);
-    case SYMLINK_DEREF_ARGSONLY:
-      return optionh_stat(file, bufp);
-    case SYMLINK_NEVER_DEREF:
-      return optionp_stat(file, bufp);
-    }
-}
-#endif /* DEBUG_STAT */
-
-void 
-set_follow_state(enum SymlinkOption opt)
-{
-  switch (opt)
-    {
-    case SYMLINK_ALWAYS_DEREF:  /* -L */
-      options.xstat = optionl_stat;
-      options.no_leaf_check = true;
-      break;
-      
-    case SYMLINK_NEVER_DEREF:	/* -P (default) */
-      options.xstat = optionp_stat;
-      /* Can't turn no_leaf_check off because the user might have specified 
-       * -noleaf anyway
-       */
-      break;
-      
-    case SYMLINK_DEREF_ARGSONLY: /* -H */
-      options.xstat = optionh_stat;
-      options.no_leaf_check = true;
-    }
+enum WdSanityCheckFatality
+  {
+    FATAL_IF_SANITY_CHECK_FAILS,
+    RETRY_IF_SANITY_CHECK_FAILS,
+    NON_FATAL_IF_SANITY_CHECK_FAILS
+  };
 
-  options.symlink_handling = opt;
-  
-  /* For DBEUG_STAT, the choice is made at runtime within debug_stat()
-   * by checking the contents of the symlink_handling variable.
-   */
-#if defined(DEBUG_STAT)
-  options.xstat = debug_stat;
-#endif /* !DEBUG_STAT */
-}
-
 
-/* Complete any outstanding commands.
- */
-void 
-cleanup(void)
-{
-  if (eval_tree)
-    {
-      complete_pending_execs(eval_tree);
-      complete_pending_execdirs(eval_tree);
-    }
-}
-
-/* Get the stat information for a file, if it is 
- * not already known. 
- */
-int
-get_statinfo (const char *pathname, const char *name, struct stat *p)
-{
-  if (!state.have_stat && (*options.xstat) (name, p) != 0)
-    {
-      if (!options.ignore_readdir_race || (errno != ENOENT) )
-	{
-	  error (0, errno, "%s", pathname);
-	  state.exit_status = 1;
-	}
-      return -1;
-    }
-  state.have_stat = true;
-  state.have_type = true;
-  state.type = p->st_mode;
-  return 0;
-}
-
-/* Get the stat/type information for a file, if it is 
- * not already known. 
- */
-int
-get_info (const char *pathname,
-	  const char *name,
-	  struct stat *p,
-	  struct predicate *pred_ptr)
+int get_current_dirfd(void)
 {
-  /* If we need the full stat info, or we need the type info but don't 
-   * already have it, stat the file now.
-   */
-  (void) name;
-  if (pred_ptr->need_stat)
-    {
-      return get_statinfo(pathname, state.rel_pathname, p);
-    }
-  if ((pred_ptr->need_type && (0 == state.have_type)))
-    {
-      return get_statinfo(pathname, state.rel_pathname, p);
-    }
-  return 0;
+  return AT_FDCWD;
 }
-
-/* Determine if we can use O_NOFOLLOW.
- */
-#if defined(O_NOFOLLOW)
-static boolean 
-check_nofollow(void)
-{
-  struct utsname uts;
-  float  release;
 
-  if (0 == uname(&uts))
-    {
-      /* POSIX requires that atof() ignore "unrecognised suffixes". */
-      release = atof(uts.release);
-      
-      if (0 == strcmp("Linux", uts.sysname))
-	{
-	  /* Linux kernels 2.1.126 and earlier ignore the O_NOFOLLOW flag. */
-	  return release >= 2.2; /* close enough */
-	}
-      else if (0 == strcmp("FreeBSD", uts.sysname)) 
-	{
-	  /* FreeBSD 3.0-CURRENT and later support it */
-	  return release >= 3.1;
-	}
-    }
-
-  /* Well, O_NOFOLLOW was defined, so we'll try to use it. */
-  return true;
-}
-#endif
 
 int
 main (int argc, char **argv)
 {
   int i;
-  PFB parse_function;		/* Pointer to the function which parses. */
-  struct predicate *cur_pred;
-  char *predicate_name;		/* Name of predicate being parsed. */
   int end_of_leading_options = 0; /* First arg after any -H/-L etc. */
+  struct predicate *eval_tree;
+
   program_name = argv[0];
+  state.exit_status = 0;
+
+  /* Set the option defaults before we do the the locale
+   * initialisation as check_nofollow() needs to be executed in the
+   * POSIX locale.
+   */
+  set_option_defaults(&options);
 
 #ifdef HAVE_SETLOCALE
   setlocale (LC_ALL, "");
@@ -387,52 +149,27 @@ main (int argc, char **argv)
   textdomain (PACKAGE);
   atexit (close_stdout);
 
-  
-  if (isatty(0))
-    {
-      options.warnings = true;
-    }
-  else
-    {
-      options.warnings = false;
-    }
-  
-  
-  predicates = NULL;
-  last_pred = NULL;
-  options.do_dir_first = true;
-  options.maxdepth = options.mindepth = -1;
-  options.start_time = time (NULL);
-  options.cur_day_start = options.start_time - DAYSECS;
-  options.full_days = false;
-  options.stay_on_filesystem = false;
-  options.ignore_readdir_race = false;
-
-  state.exit_status = 0;
+  /* Check for -P, -H or -L options. */
+  end_of_leading_options = process_leading_options(argc, argv);
 
-#if defined(DEBUG_STAT)
-  options.xstat = debug_stat;
-#endif /* !DEBUG_STAT */
+  if (options.debug_options & DebugStat)
+    options.xstat = debug_stat;
 
-  if (getenv("POSIXLY_CORRECT"))
-    options.output_block_size = 512;
-  else
-    options.output_block_size = 1024;
+#ifdef DEBUG
+  fprintf (stderr, "cur_day_start = %s", ctime (&options.cur_day_start));
+#endif /* DEBUG */
 
-#ifdef O_NOFOLLOW
-  options.open_nofollow_available = check_nofollow();
-#else
-  options.open_nofollow_available = false;
-#endif
+  /* state.cwd_dir_fd has to be initialised before we call build_expression_tree()
+   * because command-line parsing may lead us to stat some files.
+   */
+  state.cwd_dir_fd = AT_FDCWD;
   
-  if (getenv("FIND_BLOCK_SIZE"))
-    {
-      error (1, 0, _("The environment variable FIND_BLOCK_SIZE is not supported, the only thing that affects the block size is the POSIXLY_CORRECT environment variable"));
-    }
-
-  options.no_leaf_check = false;
-  set_follow_state(SYMLINK_NEVER_DEREF); /* The default is equivalent to -P. */
+  /* We are now processing the part of the "find" command line 
+   * after the -H/-L options (if any).
+   */
+  eval_tree = build_expression_tree(argc, argv, end_of_leading_options);
 
+  
   /* safely_chdir() needs to check that it has ended up in the right place. 
    * To avoid bailing out when something gets automounted, it checks if 
    * the target directory appears to have had a directory mounted on it as
@@ -445,164 +182,32 @@ main (int argc, char **argv)
    */
   if (!options.open_nofollow_available)
     {
-      init_mounted_dev_list();
-    }
-  
-#ifdef DEBUG
-  fprintf (stderr, "cur_day_start = %s", ctime (&options.cur_day_start));
-#endif /* DEBUG */
-
-  /* Check for -P, -H or -L options. */
-  for (i=1; (end_of_leading_options = i) < argc; ++i)
-    {
-      if (0 == strcmp("-H", argv[i]))
-	{
-	  /* Meaning: dereference symbolic links on command line, but nowhere else. */
-	  set_follow_state(SYMLINK_DEREF_ARGSONLY);
-	}
-      else if (0 == strcmp("-L", argv[i]))
-	{
-	  /* Meaning: dereference all symbolic links. */
-	  set_follow_state(SYMLINK_ALWAYS_DEREF);
-	}
-      else if (0 == strcmp("-P", argv[i]))
-	{
-	  /* Meaning: never dereference symbolic links (default). */
-	  set_follow_state(SYMLINK_NEVER_DEREF);
-	}
-      else if (0 == strcmp("--", argv[i]))
-	{
-	  /* -- signifies the end of options. */
-	  end_of_leading_options = i+1;	/* Next time start with the next option */
-	  break;
-	}
-      else
-	{
-	  /* Hmm, must be one of 
-	   * (a) A path name
-	   * (b) A predicate
-	   */
-	  end_of_leading_options = i; /* Next time start with this option */
-	  break;
-	}
-    }
-
-  /* We are now processing the part of the "find" command line 
-   * after the -H/-L options (if any).
-   */
-
-  /* fprintf(stderr, "rest: optind=%ld\n", (long)optind); */
-  
-  /* Find where in ARGV the predicates begin. */
-  for (i = end_of_leading_options; i < argc && strchr ("-!(),", argv[i][0]) == NULL; i++)
-    {
-      /* fprintf(stderr, "Looks like %s is not a predicate\n", argv[i]); */
-      /* Do nothing. */ ;
-    }
-  
-  /* Enclose the expression in `( ... )' so a default -print will
-     apply to the whole expression. */
-  parse_open (argv, &argc);
-  /* Build the input order list. */
-  while (i < argc)
-    {
-      if (strchr ("-!(),", argv[i][0]) == NULL)
-	usage (_("paths must precede expression"));
-      predicate_name = argv[i];
-      parse_function = find_parser (predicate_name);
-      if (parse_function == NULL)
-	/* Command line option not recognized */
-	error (1, 0, _("invalid predicate `%s'"), predicate_name);
-      i++;
-      if (!(*parse_function) (argv, &i))
-	{
-	  if (argv[i] == NULL)
-	    /* Command line option requires an argument */
-	    error (1, 0, _("missing argument to `%s'"), predicate_name);
-	  else
-	    error (1, 0, _("invalid argument `%s' to `%s'"),
-		   argv[i], predicate_name);
-	}
-    }
-  if (predicates->pred_next == NULL)
-    {
-      /* No predicates that do something other than set a global variable
-	 were given; remove the unneeded initial `(' and add `-print'. */
-      cur_pred = predicates;
-      predicates = last_pred = predicates->pred_next;
-      free ((char *) cur_pred);
-      parse_print (argv, &argc);
-    }
-  else if (!default_prints (predicates->pred_next))
-    {
-      /* One or more predicates that produce output were given;
-	 remove the unneeded initial `('. */
-      cur_pred = predicates;
-      predicates = predicates->pred_next;
-      free ((char *) cur_pred);
-    }
-  else
-    {
-      /* `( user-supplied-expression ) -print'. */
-      parse_close (argv, &argc);
-      parse_print (argv, &argc);
-    }
-
-#ifdef	DEBUG
-  fprintf (stderr, _("Predicate List:\n"));
-  print_list (stderr, predicates);
-#endif /* DEBUG */
-
-  /* Done parsing the predicates.  Build the evaluation tree. */
-  cur_pred = predicates;
-  eval_tree = get_expr (&cur_pred, NO_PREC);
-
-  /* Check if we have any left-over predicates (this fixes
-   * Debian bug #185202).
-   */
-  if (cur_pred != NULL)
-    {
-      error (1, 0, _("unexpected extra predicate"));
+#ifdef STAT_MOUNTPOINTS
+      init_mounted_dev_list(0);
+#endif
     }
   
-#ifdef	DEBUG
-  fprintf (stderr, _("Eval Tree:\n"));
-  print_tree (stderr, eval_tree, 0);
-#endif /* DEBUG */
-
-  /* Rearrange the eval tree in optimal-predicate order. */
-  opt_expr (&eval_tree);
-
-  /* Determine the point, if any, at which to stat the file. */
-  mark_stat (eval_tree);
-  /* Determine the point, if any, at which to determine file type. */
-  mark_type (eval_tree);
 
-#ifdef DEBUG
-  fprintf (stderr, _("Optimized Eval Tree:\n"));
-  print_tree (stderr, eval_tree, 0);
-  fprintf (stderr, _("Optimized command line:\n"));
-  print_optlist(stderr, eval_tree);
-  fprintf(stderr, "\n");
-#endif /* DEBUG */
-
-  starting_desc = open (".", O_RDONLY);
+  starting_desc = open (".", O_RDONLY|O_LARGEFILE);
   if (0 <= starting_desc && fchdir (starting_desc) != 0)
     {
       close (starting_desc);
       starting_desc = -1;
     }
+  assert(starting_desc >= 0);
+
   if (starting_desc < 0)
     {
       starting_dir = xgetcwd ();
       if (! starting_dir)
 	error (1, errno, _("cannot get current directory"));
     }
+  set_stat_placeholders(&starting_stat_buf);
   if ((*options.xstat) (".", &starting_stat_buf) != 0)
-    error (1, errno, _("cannot get current directory"));
+    error (1, errno, _("cannot stat current directory"));
 
   /* If no paths are given, default to ".".  */
-  for (i = end_of_leading_options; i < argc && strchr ("-!(),", argv[i][0]) == NULL; i++)
+  for (i = end_of_leading_options; i < argc && !looks_like_expression(argv[i], true); i++)
     {
       process_top_path (argv[i], 0);
     }
@@ -627,19 +232,26 @@ main (int argc, char **argv)
   cleanup();
   return state.exit_status;
 }
+
+boolean is_fts_enabled(int *ftsoptions)
+{
+  /* this version of find (i.e. this main()) does not use fts. */
+  *ftsoptions = 0;
+  return false;
+}
 
-
+
 static char *
 specific_dirname(const char *dir)
 {
-  char dirname[1024];
+  char dirbuf[1024];
 
   if (0 == strcmp(".", dir))
     {
       /* OK, what's '.'? */
-      if (NULL != getcwd(dirname, sizeof(dirname)))
+      if (NULL != getcwd(dirbuf, sizeof(dirbuf)))
 	{
-	  return strdup(dirname);
+	  return strdup(dirbuf);
 	}
       else
 	{
@@ -656,16 +268,34 @@ specific_dirname(const char *dir)
     }
 }
 
+
+
+/* Return non-zero if FS is the name of a filesystem that is likely to
+ * be automounted
+ */
+static int
+fs_likely_to_be_automounted(const char *fs)
+{
+  return ( (0==strcmp(fs, "nfs")) || (0==strcmp(fs, "autofs")) || (0==strcmp(fs, "subfs")));
+}
+
+
+
+#ifdef STAT_MOUNTPOINTS
 static dev_t *mounted_devices = NULL;
 static size_t num_mounted_devices = 0u;
 
 
 static void
-init_mounted_dev_list()
+init_mounted_dev_list(int mandatory)
 {
   assert(NULL == mounted_devices);
   assert(0 == num_mounted_devices);
   mounted_devices = get_mounted_devices(&num_mounted_devices);
+  if (mandatory && (NULL == mounted_devices))
+    {
+      error(1, 0, "Cannot read list of mounted devices.");
+    }
 }
 
 static void
@@ -677,7 +307,7 @@ refresh_mounted_dev_list(void)
       mounted_devices = 0;
     }
   num_mounted_devices = 0u;
-  init_mounted_dev_list();
+  init_mounted_dev_list(1);
 }
 
 
@@ -722,21 +352,63 @@ get_mount_state(dev_t newdev)
     return MountPointRecentlyUnmounted;
 }
 
-
-/* Return non-zero if FS is the name of a filesystem that is likely to
- * be automounted
+
+
+/* We stat()ed a directory, chdir()ed into it (we know this 
+ * since direction is TraversingDown), stat()ed it again,
+ * and noticed that the device numbers are different.  Check
+ * if the filesystem was recently mounted. 
+ * 
+ * If it was, it looks like chdir()ing into the directory
+ * caused a filesystem to be mounted.  Maybe automount is
+ * running.  Anyway, that's probably OK - but it happens
+ * only when we are moving downward.
+ *
+ * We also allow for the possibility that a similar thing
+ * has happened with the unmounting of a filesystem.  This
+ * is much rarer, as it relies on an automounter timeout
+ * occurring at exactly the wrong moment.
  */
-static int
-fs_likely_to_be_automounted(const char *fs)
-{
-  return ( (0==strcmp(fs, "nfs")) || (0==strcmp(fs, "autofs")) || (0==strcmp(fs, "subfs")));
+static enum WdSanityCheckFatality
+dirchange_is_fatal(const char *specific_what,
+		   enum WdSanityCheckFatality isfatal,
+		   int silent,
+		   struct stat *newinfo)
+{
+  enum MountPointStateChange transition = get_mount_state(newinfo->st_dev);
+  switch (transition)
+    {
+    case MountPointRecentlyUnmounted:
+      isfatal = NON_FATAL_IF_SANITY_CHECK_FAILS;
+      if (!silent)
+	{
+	  error (0, 0,
+		 _("Warning: filesystem %s has recently been unmounted."),
+		 specific_what);
+	}
+      break;
+	      
+    case MountPointRecentlyMounted:
+      isfatal = NON_FATAL_IF_SANITY_CHECK_FAILS;
+      if (!silent)
+	{
+	  error (0, 0,
+		 _("Warning: filesystem %s has recently been mounted."),
+		 specific_what);
+	}
+      break;
+
+    case MountPointStateUnchanged:
+      /* leave isfatal as it is */
+      break;
+    }
+  
+  return isfatal;
 }
 
-enum WdSanityCheckFatality
-  {
-    FATAL_IF_SANITY_CHECK_FAILS,
-    NON_FATAL_IF_SANITY_CHECK_FAILS
-  };
+
+#endif
+
 
 
 /* Examine the results of the stat() of a directory from before we
@@ -769,7 +441,7 @@ enum WdSanityCheckFatality
  */
 static boolean
 wd_sanity_check(const char *thing_to_stat,
-		const char *program_name,
+		const char *progname,
 		const char *what,
 		dev_t old_dev,
 		ino_t old_ino,
@@ -783,94 +455,66 @@ wd_sanity_check(const char *thing_to_sta
   const char *fstype;
   char *specific_what = NULL;
   int silent = 0;
+  const char *current_dir = ".";
   
   *changed = false;
   
-  if ((*options.xstat) (".", newinfo) != 0)
+  set_stat_placeholders(newinfo);
+  if ((*options.xstat) (current_dir, newinfo) != 0)
     error (1, errno, "%s", thing_to_stat);
   
   if (old_dev != newinfo->st_dev)
     {
       *changed = true;
       specific_what = specific_dirname(what);
-      fstype = filesystem_type(newinfo);
+      fstype = filesystem_type(newinfo, current_dir);
       silent = fs_likely_to_be_automounted(fstype);
-      
+
       /* This condition is rare, so once we are here it is 
        * reasonable to perform an expensive computation to 
        * determine if we should continue or fail. 
        */
       if (TraversingDown == direction)
 	{
-	  /* We stat()ed a directory, chdir()ed into it (we know this 
-	   * since direction is TraversingDown), stat()ed it again,
-	   * and noticed that the device numbers are different.  Check
-	   * if the filesystem was recently mounted. 
-	   * 
-	   * If it was, it looks like chdir()ing into the directory
-	   * caused a filesystem to be mounted.  Maybe automount is
-	   * running.  Anyway, that's probably OK - but it happens
-	   * only when we are moving downward.
-	   *
-	   * We also allow for the possibility that a similar thing
-	   * has happened with the unmounting of a filesystem.  This
-	   * is much rarer, as it relies on an automounter timeout
-	   * occurring at exactly the wrong moment.
-	   */
-	  enum MountPointStateChange transition = get_mount_state(newinfo->st_dev);
-	  switch (transition)
-	    {
-	    case MountPointRecentlyUnmounted:
-	      isfatal = NON_FATAL_IF_SANITY_CHECK_FAILS;
-	      if (!silent)
-		{
-		  error (0, 0,
-			 _("Warning: filesystem %s has recently been unmounted."),
-			 specific_what);
-		}
-	      break;
-	      
-	    case MountPointRecentlyMounted:
-	      isfatal = NON_FATAL_IF_SANITY_CHECK_FAILS;
-	      if (!silent)
-		{
-		  error (0, 0,
-			 _("Warning: filesystem %s has recently been mounted."),
-			 specific_what);
-		}
-	      break;
-
-	    case MountPointStateUnchanged:
-	      /* leave isfatal as it is */
-	      break;
-	    }
+#ifdef STAT_MOUNTPOINTS
+	  isfatal = dirchange_is_fatal(specific_what,isfatal,silent,newinfo);
+#else
+	  isfatal = RETRY_IF_SANITY_CHECK_FAILS;
+#endif
 	}
 
-      if (FATAL_IF_SANITY_CHECK_FAILS == isfatal)
+      switch (isfatal)
 	{
-	  fstype = filesystem_type(newinfo);
-	  error (1, 0,
-		 _("%s%s changed during execution of %s (old device number %ld, new device number %ld, filesystem type is %s) [ref %ld]"),
-		 specific_what,
-		 parent ? "/.." : "",
-		 program_name,
-		 (long) old_dev,
-		 (long) newinfo->st_dev,
-		 fstype,
-		 line_no);
-	  /*NOTREACHED*/
+	case FATAL_IF_SANITY_CHECK_FAILS:
+	  {
+	    fstype = filesystem_type(newinfo, current_dir);
+	    error (1, 0,
+		   _("%s%s changed during execution of %s (old device number %ld, new device number %ld, filesystem type is %s) [ref %ld]"),
+		   specific_what,
+		   parent ? "/.." : "",
+		   progname,
+		   (long) old_dev,
+		   (long) newinfo->st_dev,
+		   fstype,
+		   line_no);
+	    /*NOTREACHED*/
+	    return false;
+	  }
+	  
+	case NON_FATAL_IF_SANITY_CHECK_FAILS:
+	  {
+	    /* Since the device has changed under us, the inode number 
+	     * will almost certainly also be different. However, we have 
+	     * already decided that this is not a problem.  Hence we return
+	     * without checking the inode number.
+	     */
+	    free(specific_what);
+	    return true;
+	  }
+
+	case RETRY_IF_SANITY_CHECK_FAILS:
 	  return false;
 	}
-      else
-	{
-	  /* Since the device has changed under us, the inode number 
-	   * will almost certainly also be different. However, we have 
-	   * already decided that this is not a problem.  Hence we return
-	   * without checking the inode number.
-	   */
-	  free(specific_what);
-	  return true;
-	}
     }
 
   /* Device number was the same, check if the inode has changed. */
@@ -878,14 +522,14 @@ wd_sanity_check(const char *thing_to_sta
     {
       *changed = true;
       specific_what = specific_dirname(what);
-      fstype = filesystem_type(newinfo);
+      fstype = filesystem_type(newinfo, current_dir);
       
       error ((isfatal == FATAL_IF_SANITY_CHECK_FAILS) ? 1 : 0,
 	     0,			/* no relevant errno value */
 	     _("%s%s changed during execution of %s (old inode number %ld, new inode number %ld, filesystem type is %s) [ref %ld]"),
 	     specific_what, 
 	     parent ? "/.." : "",
-	     program_name,
+	     progname,
 	     (long) old_ino,
 	     (long) newinfo->st_ino,
 	     fstype,
@@ -905,45 +549,52 @@ enum SafeChdirStatus
     SafeChdirFailStat,
     SafeChdirFailWouldBeUnableToReturn,
     SafeChdirFailChdirFailed,
-    SafeChdirFailNonexistent
+    SafeChdirFailNonexistent,
+    SafeChdirFailDestUnreadable
   };
 
-/* Safely perform a change in directory.
+/* Safely perform a change in directory.  We do this by calling
+ * lstat() on the subdirectory, using chdir() to move into it, and
+ * then lstat()ing ".".  We compare the results of the two stat calls
+ * to see if they are consistent.  If not, we sound the alarm.
  *
+ * If following_links() is true, we do follow symbolic links.
  */
 static enum SafeChdirStatus
 safely_chdir_lstat(const char *dest,
 		   enum TraversalDirection direction,
 		   struct stat *statbuf_dest,
-		   enum ChdirSymlinkHandling symlink_handling)
+		   enum ChdirSymlinkHandling symlink_follow_option,
+		   boolean *did_stat)
 {
   struct stat statbuf_arrived;
   int rv, dotfd=-1;
   int saved_errno;		/* specific_dirname() changes errno. */
-  char *name = NULL;
   boolean rv_set = false;
+  boolean statflag = false;
+  int tries = 0;
+  enum WdSanityCheckFatality isfatal = RETRY_IF_SANITY_CHECK_FAILS;
   
-  /* We're about to leave a directory.  If there are any -execdir
-   * argument lists which have been built but have not yet been
-   * processed, do them now because they must be done in the same
-   * directory.
-   */
-  complete_pending_execdirs(eval_tree);
-  
-
   saved_errno = errno = 0;
-  time(NULL);
-  opendir(".");
-  time(NULL);
 
-  dotfd = open(".", O_RDONLY);
+  dotfd = open(".", O_RDONLY|O_LARGEFILE);
+
+  /* We jump back to here if wd_sanity_check()
+   * recoverably triggers an alert.
+   */
+ retry:
+  ++tries;
+  
   if (dotfd >= 0)
     {
       /* Stat the directory we're going to. */
+      set_stat_placeholders(statbuf_dest);
       if (0 == options.xstat(dest, statbuf_dest))
 	{
+	  statflag = true;
+	  
 #ifdef S_ISLNK
-	  /* symlink_handling might be set to SymlinkFollowOk, which
+	  /* symlink_follow_option might be set to SymlinkFollowOk, which
 	   * would allow us to chdir() into a symbolic link.  This is
 	   * only useful for the case where the directory we're
 	   * chdir()ing into is the basename of a command line
@@ -956,10 +607,10 @@ safely_chdir_lstat(const char *dest,
 	  if (!following_links() && S_ISLNK(statbuf_dest->st_mode))
 	    {
 	      /* We're not supposed to be following links, but this is 
-	       * a link.  Check symlink_handling to see if we should 
+	       * a link.  Check symlink_follow_option to see if we should 
 	       * make a special exception.
 	       */
-	      if (symlink_handling == SymlinkFollowOk)
+	      if (symlink_follow_option == SymlinkFollowOk)
 		{
 		  /* We need to re-stat() the file so that the 
 		   * sanity check can pass. 
@@ -971,6 +622,7 @@ safely_chdir_lstat(const char *dest,
 		      saved_errno = errno;
 		      goto fail;
 		    }
+		  statflag = true;
 		}
 	      else
 		{
@@ -998,21 +650,54 @@ safely_chdir_lstat(const char *dest,
 	      saved_errno = 0;	/* silence the error message */
 	      goto fail;
 	    }
-#endif	  
-#ifdef DEBUG_STAT
-	  fprintf(stderr, "safely_chdir(): chdir(\"%s\")\n", dest);
 #endif
+	  
+	  if (options.debug_options & DebugSearch)
+	    fprintf(stderr, "safely_chdir(): chdir(\"%s\")\n", dest);
+
 	  if (0 == chdir(dest))
 	    {
 	      /* check we ended up where we wanted to go */
 	      boolean changed = false;
-	      wd_sanity_check(".", program_name, ".",
-			      statbuf_dest->st_dev,
-			      statbuf_dest->st_ino,
-			      &statbuf_arrived, 
-			      0, __LINE__, direction,
-			      FATAL_IF_SANITY_CHECK_FAILS,
-			      &changed);
+	      if (!wd_sanity_check(".", program_name, ".",
+				   statbuf_dest->st_dev,
+				   statbuf_dest->st_ino,
+				   &statbuf_arrived, 
+				   0, __LINE__, direction,
+				   isfatal,
+				   &changed))
+		{
+		  /* Only allow one failure. */
+		  if (RETRY_IF_SANITY_CHECK_FAILS == isfatal)
+		    {
+		      if (0 == fchdir(dotfd))
+			{
+			  isfatal = FATAL_IF_SANITY_CHECK_FAILS;
+			  goto retry;
+			}
+		      else
+			{
+			  /* Failed to return to original directory,
+			   * but we know that the current working
+			   * directory is not the one that we intend
+			   * to be in.  Since fchdir() failed, we
+			   * can't recover from this and so this error
+			   * is fatal.
+			   */
+			  error(1, errno,
+				"failed to return to parent directory");
+			}
+		    }
+		  else
+		    {
+		      /* XXX: not sure what to use as an excuse here. */
+		      rv = SafeChdirFailNonexistent;
+		      rv_set = true;
+		      saved_errno = 0;
+		      goto fail;
+		    }
+		}
+
 	      close(dotfd);
 	      return SafeChdirOK;
 	    }
@@ -1025,8 +710,6 @@ safely_chdir_lstat(const char *dest,
 		  rv_set = true;
 		  if (options.ignore_readdir_race)
 		    errno = 0;	/* don't issue err msg */
-		  else
-		    name = specific_dirname(dest);
 		}
 	      else if (ENOTDIR == saved_errno)
 		{
@@ -1042,7 +725,6 @@ safely_chdir_lstat(const char *dest,
 		{
 		  rv = SafeChdirFailChdirFailed;
 		  rv_set = true;
-		  name = specific_dirname(dest);
 		}
 	      goto fail;
 	    }
@@ -1052,7 +734,7 @@ safely_chdir_lstat(const char *dest,
 	  saved_errno = errno;
 	  rv = SafeChdirFailStat;
 	  rv_set = true;
-	  name = specific_dirname(dest);
+
 	  if ( (ENOENT == saved_errno) || (0 == state.curdepth))
 	    saved_errno = 0;	/* don't issue err msg */
 	  goto fail;
@@ -1066,57 +748,84 @@ safely_chdir_lstat(const char *dest,
       goto fail;
     }
 
+  /* This is the success path, so we clear errno.  The caller probably
+   * won't be calling error() anyway.
+   */
   saved_errno = 0;
   
-  /* We use the same exit path for successs or failure. 
+  /* We use the same exit path for success or failure. 
    * which has occurred is recorded in RV. 
    */
  fail:
+  /* We do not call error() as this would result in a duplicate error
+   * message when the caller does the same thing.
+   */
   if (saved_errno)
-    {
-      errno = saved_errno;
-      
-      /* do not call error() as this would result in a duplicate error message 
-       * when the caller does the same thing. 
-       */
-    }
-  
-  free(name);
-  name = NULL;
+    errno = saved_errno;
   
   if (dotfd >= 0)
     {
       close(dotfd);
       dotfd = -1;
     }
+  
+  *did_stat = statflag;
   assert(rv_set);
   return rv;
 }
 
-
+#if defined(O_NOFOLLOW)
+/* Safely change working directory to the specified subdirectory.  If
+ * we are not allowed to follow symbolic links, we use open() with
+ * O_NOFOLLOW, followed by fchdir().  This ensures that we don't
+ * follow symbolic links (of course, we do follow them if the -L
+ * option is in effect).
+ */
 static enum SafeChdirStatus
 safely_chdir_nofollow(const char *dest,
 		      enum TraversalDirection direction,
 		      struct stat *statbuf_dest,
-		      enum ChdirSymlinkHandling symlink_handling)
+		      enum ChdirSymlinkHandling symlink_follow_option,
+		      boolean *did_stat)
 {
-#ifdef O_NOFOLLOW
-  int extraflags = following_links() ? 0 : O_NOFOLLOW;
-#else
-  int extraflags = 0;
-#endif
+  int extraflags, fd;
 
-  int fd = open(dest, O_RDONLY|extraflags);
+  (void) direction;
+  (void) statbuf_dest;
+  
+  extraflags = 0;
+  *did_stat = false;
+  
+  switch (symlink_follow_option)
+    {
+    case SymlinkFollowOk:
+      extraflags = 0;
+      break;
+      
+    case SymlinkHandleDefault:
+      if (following_links())
+	extraflags = 0;
+      else
+	extraflags = O_NOFOLLOW;
+      break;
+    }
+  
+  errno = 0;
+  fd = open(dest, O_RDONLY|O_LARGEFILE|extraflags);
   if (fd < 0)
     {
-      /* POSIX normally requires this to fail with EISDIR, but
-       * it's worth a try.
-       */
-      fd = open(dest, O_WRONLY|extraflags);
-      if (fd < 0)
-	goto fallback;
+      switch (errno)
+	{
+	case ELOOP:
+	  return SafeChdirFailSymlink; /* This is why we use O_NOFOLLOW */
+	case ENOENT:
+	  return SafeChdirFailNonexistent;
+	default:
+	  return SafeChdirFailDestUnreadable;
+	}
     }
-
+  
+  errno = 0;
   if (0 == fchdir(fd))
     {
       close(fd);
@@ -1124,29 +833,50 @@ safely_chdir_nofollow(const char *dest,
     }
   else
     {
+      int saved_errno = errno;
       close(fd);
-      goto fallback;
+      errno = saved_errno;
+      
+      switch (errno)
+	{
+	case ENOTDIR:
+	  return SafeChdirFailNotDir;
+	  
+	case EACCES:
+	case EBADF:		/* Shouldn't happen */
+	case EINTR:
+	case EIO:
+	default:
+	  return SafeChdirFailChdirFailed;
+	}
     }
-  
- fallback:  
-  if (NULL == mounted_devices)
-    init_mounted_dev_list();
-  
-  return safely_chdir_lstat(dest, direction, statbuf_dest, symlink_handling);
 }
+#endif
 
 static enum SafeChdirStatus
 safely_chdir(const char *dest,
 	     enum TraversalDirection direction,
 	     struct stat *statbuf_dest,
-	     enum ChdirSymlinkHandling symlink_handling)
+	     enum ChdirSymlinkHandling symlink_follow_option,
+	     boolean *did_stat)
 {
-#if defined O_NOFOLLOW  
-  if (options.open_nofollow_available)
-    return safely_chdir_nofollow(dest, direction, statbuf_dest, symlink_handling);
-#endif
+  enum SafeChdirStatus result;
   
-  return safely_chdir_lstat(dest, direction, statbuf_dest, symlink_handling);
+  /* We're about to leave a directory.  If there are any -execdir
+   * argument lists which have been built but have not yet been
+   * processed, do them now because they must be done in the same
+   * directory.
+   */
+  complete_pending_execdirs(get_current_dirfd());
+
+#if !defined(O_NOFOLLOW)
+  options.open_nofollow_available = false;
+#endif
+  if (options.open_nofollow_available)
+    result = safely_chdir_nofollow(dest, direction, statbuf_dest, symlink_follow_option, did_stat);
+  else
+    result = safely_chdir_lstat(dest, direction, statbuf_dest, symlink_follow_option, did_stat);
+  return result;
 }
 
 
@@ -1160,15 +890,16 @@ chdir_back (void)
   
   if (starting_desc < 0)
     {
-#ifdef DEBUG_STAT
-      fprintf(stderr, "chdir_back(): chdir(\"%s\")\n", starting_dir);
-#endif
+      if (options.debug_options & DebugSearch)
+	fprintf(stderr, "chdir_back(): chdir(\"%s\")\n", starting_dir);
       
+#ifdef STAT_MOUNTPOINTS
       /* We will need the mounted device list.  Get it now if we don't
        * already have it.
        */
       if (NULL == mounted_devices)
-	init_mounted_dev_list();
+	init_mounted_dev_list(1);
+#endif
       
       if (chdir (starting_dir) != 0)
 	error (1, errno, "%s", starting_dir);
@@ -1185,34 +916,38 @@ chdir_back (void)
     }
   else
     {
-#ifdef DEBUG_STAT
-      fprintf(stderr, "chdir_back(): chdir(<starting-point>)\n");
-#endif
+      if (options.debug_options & DebugSearch)
+	fprintf(stderr, "chdir_back(): chdir(<starting-point>)\n");
+
       if (fchdir (starting_desc) != 0)
-	error (1, errno, "%s", starting_dir);
+	{
+	  error (1, errno, "%s", starting_dir);
+	}
     }
 }
 
-/* Descend PATHNAME, which is a command-line argument.  
-   Actions like -execdir assume that we are in the 
-   parent directory of the file we're examining, 
-   and on entry to this function our working directory
-   is whetever it was when find was invoked.  Therefore
-   If PATHNAME is "." we just leave things as they are. 
-   Otherwise, we figure out what the parent directory is, 
-   and move to that.
-*/
+/* Move to the parent of a given directory and then call a function,
+ * restoring the cwd.  Don't bother changing directory if the
+ * specified directory is a child of "." or is the root directory.
+ */
 static void
-process_top_path (char *pathname, mode_t mode)
+at_top (char *pathname,
+	mode_t mode,
+	struct stat *pstat,
+	void (*action)(char *pathname,
+		       char *basename,
+		       int mode,
+		       struct stat *pstat))
 {
   int dirchange;
   char *parent_dir = dir_name(pathname);
   char *base = base_name(pathname);
   
   state.curdepth = 0;
-  state.path_length = strlen (pathname);
+  state.starting_path_length = strlen (pathname);
 
-  if (0 == strcmp(pathname, parent_dir))
+  if (0 == strcmp(pathname, parent_dir)
+      || 0 == strcmp(parent_dir, "."))
     {
       dirchange = 0;
       base = pathname;
@@ -1222,7 +957,8 @@ process_top_path (char *pathname, mode_t
       enum TraversalDirection direction;
       enum SafeChdirStatus chdir_status;
       struct stat st;
-
+      boolean did_stat = false;
+      
       dirchange = 1;
       if (0 == strcmp(base, ".."))
 	direction = TraversingUp;
@@ -1239,7 +975,7 @@ process_top_path (char *pathname, mode_t
        * Hence we need the ability to override the policy set by
        * following_links().
        */
-      chdir_status = safely_chdir(parent_dir, direction, &st, SymlinkFollowOk);
+      chdir_status = safely_chdir(parent_dir, direction, &st, SymlinkFollowOk, &did_stat);
       if (SafeChdirOK != chdir_status)
 	{
 	  const char *what = (SafeChdirFailWouldBeUnableToReturn == chdir_status) ? "." : parent_dir;
@@ -1258,8 +994,7 @@ process_top_path (char *pathname, mode_t
   free (parent_dir);
   parent_dir = NULL;
   
-  process_path (pathname, base, false, ".", mode);
-  complete_pending_execdirs(eval_tree);
+  action(pathname, base, mode, pstat);
   
   if (dirchange)
     {
@@ -1268,6 +1003,48 @@ process_top_path (char *pathname, mode_t
 }
 
 
+static void do_process_top_dir(char *pathname,
+			       char *base,
+			       int mode,
+			       struct stat *pstat)
+{
+  (void) pstat;
+  
+  process_path (pathname, base, false, ".", mode);
+  complete_pending_execdirs(get_current_dirfd());
+}
+
+static void do_process_predicate(char *pathname,
+				 char *base,
+				 int mode,
+				 struct stat *pstat)
+{
+  (void) mode;
+  
+  state.rel_pathname = base;	/* cwd_dir_fd was already set by safely_chdir */
+  apply_predicate (pathname, pstat, get_eval_tree());
+}
+
+
+
+
+/* Descend PATHNAME, which is a command-line argument.  
+
+   Actions like -execdir assume that we are in the 
+   parent directory of the file we're examining, 
+   and on entry to this function our working directory
+   is whatever it was when find was invoked.  Therefore
+   If PATHNAME is "." we just leave things as they are. 
+   Otherwise, we figure out what the parent directory is, 
+   and move to that.
+*/
+static void
+process_top_path (char *pathname, mode_t mode)
+{
+  at_top(pathname, mode, NULL, do_process_top_dir);
+}
+
+
 /* Info on each directory in the current tree branch, to avoid
    getting stuck in symbolic link loops.  */
 static struct dir_id *dir_ids = NULL;
@@ -1326,6 +1103,8 @@ issue_loop_warning(const char *name, con
     }
 }
 
+
+
 /* Recursively descend path PATHNAME, applying the predicates.
    LEAF is true if PATHNAME is known to be in a directory that has no
    more unexamined subdirectories, and therefore it is not a directory.
@@ -1347,7 +1126,9 @@ process_path (char *pathname, char *name
   struct stat stat_buf;
   static dev_t root_dev;	/* Device ID of current argument pathname. */
   int i;
+  struct predicate *eval_tree;
 
+  eval_tree = get_eval_tree();
   /* Assume it is a non-directory initially. */
   stat_buf.st_mode = 0;
   state.rel_pathname = name;
@@ -1355,51 +1136,8 @@ process_path (char *pathname, char *name
   state.have_stat = false;
   state.have_type = false;
 
-  /* If we know the type of the directory entry, and it is not a
-   * symbolic link, we may be able to avoid a stat() or lstat() call.
-   */
-  if (mode)
-    {
-      if (S_ISLNK(mode) && following_links())
-	{
-	  /* mode is wrong because we should have followed the symlink. */
-	  if (get_statinfo(pathname, name, &stat_buf) != 0)
-	    return 0;
-	  mode = state.type = stat_buf.st_mode;
-	  state.have_type = true;
-	}
-      else
-	{
-	  state.have_type = true;
-	  stat_buf.st_mode = state.type = mode;
-	}
-    }
-  else
-    {
-      /* Mode is not yet known; may have to stat the file unless we 
-       * can deduce that it is not a directory (which is all we need to 
-       * know at this stage)
-       */
-      if (leaf)
-	{
-	  state.have_stat = false;
-	  state.have_type = false;;
-	  state.type = 0;
-	}
-      else
-	{
-	  if (get_statinfo(pathname, name, &stat_buf) != 0)
-	    return 0;
-
-	  /* If -L is in effect and we are dealing with a symlink,
-	   * st_mode is the mode of the pointed-to file, while mode is
-	   * the mode of the directory entry (S_IFLNK).  Hence now
-	   * that we have the stat information, override "mode".
-	   */
-	  state.type = stat_buf.st_mode;
-	  state.have_type = true;
-	}
-    }
+  if (!digest_mode(mode, pathname, name, &stat_buf, leaf))
+    return 0;
   
   if (!S_ISDIR (state.type))
     {
@@ -1411,13 +1149,20 @@ process_path (char *pathname, char *name
   /* From here on, we're working on a directory.  */
 
   
-  /* Now we really need to stat the directory, even if we knoe the
+  /* Now we really need to stat the directory, even if we know the
    * type, because we need information like struct stat.st_rdev.
    */
-  if (get_statinfo(pathname, name, &stat_buf) != 0)
-    return 0;
+  if (0 == stat_buf.st_mode)
+    {
+      /* This call was made conditional on Sat Apr 14 16:01:01 2007,
+       * and at that time the test suite passed without it.  Omitting
+       * this stat call saves a lot of system calls.
+       */
+      if (get_statinfo(pathname, name, &stat_buf) != 0)
+	return 0;
 
-  state.have_stat = true;
+      state.have_stat = true;
+    }
   mode = state.type = stat_buf.st_mode;	/* use full info now that we have it. */
   state.stop_at_current_level =
     options.maxdepth >= 0
@@ -1453,10 +1198,9 @@ process_path (char *pathname, char *name
   if (options.do_dir_first && state.curdepth >= options.mindepth)
     apply_predicate (pathname, &stat_buf, eval_tree);
 
-#ifdef DEBUG
-  fprintf(stderr, "pathname = %s, stop_at_current_level = %d\n",
-	  pathname, state.stop_at_current_level);
-#endif /* DEBUG */
+  if (options.debug_options & DebugSearch)
+    fprintf(stderr, "pathname = %s, stop_at_current_level = %d\n",
+	    pathname, state.stop_at_current_level);
   
   if (state.stop_at_current_level == false)
     /* Scan directory on disk. */
@@ -1464,91 +1208,24 @@ process_path (char *pathname, char *name
 
   if (options.do_dir_first == false && state.curdepth >= options.mindepth)
     {
-      state.rel_pathname = name;
-      apply_predicate (pathname, &stat_buf, eval_tree);
-    }
-
-  dir_curr--;
+      /* The fields in 'state' are now out of date.  Correct them.
+       */
+      if (!digest_mode(mode, pathname, name, &stat_buf, leaf))
+	return 0;
 
-  return 1;
-}
-
-/* Examine the predicate list for instances of -execdir or -okdir
- * which have been terminated with '+' (build argument list) rather
- * than ';' (singles only).  If there are any, run them (this will
- * have no effect if there are no arguments waiting).
- */
-static void
-complete_pending_execdirs(struct predicate *p)
-{
-#if defined(NEW_EXEC)
-  if (NULL == p)
-    return;
-  
-  complete_pending_execdirs(p->pred_left);
-  
-  if (p->pred_func == pred_execdir || p->pred_func == pred_okdir)
-    {
-      /* It's an exec-family predicate.  p->args.exec_val is valid. */
-      if (p->args.exec_vec.multiple)
+      if (0 == dir_curr)
 	{
-	  struct exec_val *execp = &p->args.exec_vec;
-	  
-	  /* This one was terminated by '+' and so might have some
-	   * left... Run it if neccessary.  
-	   */
-	  if (execp->state.todo)
-	    {
-	      /* There are not-yet-executed arguments. */
-	      launch (&execp->ctl, &execp->state);
-	    }
+	  at_top(pathname, mode, &stat_buf, do_process_predicate);
 	}
-    }
-
-  complete_pending_execdirs(p->pred_right);
-#else
-  /* nothing to do. */
-  return;
-#endif
-}
-
-/* Examine the predicate list for instances of -exec which have been
- * terminated with '+' (build argument list) rather than ';' (singles
- * only).  If there are any, run them (this will have no effect if
- * there are no arguments waiting).
- */
-static void
-complete_pending_execs(struct predicate *p)
-{
-#if defined(NEW_EXEC)
-  if (NULL == p)
-    return;
-  
-  complete_pending_execs(p->pred_left);
-  
-  /* It's an exec-family predicate then p->args.exec_val is valid
-   * and we can check it. 
-   */
-  if (p->pred_func == pred_exec && p->args.exec_vec.multiple)
-    {
-      struct exec_val *execp = &p->args.exec_vec;
-      
-      /* This one was terminated by '+' and so might have some
-       * left... Run it if neccessary.  Set state.exit_status if
-       * there are any problems.
-       */
-      if (execp->state.todo)
+      else
 	{
-	  /* There are not-yet-executed arguments. */
-	  launch (&execp->ctl, &execp->state);
+	  do_process_predicate(pathname, name, mode, &stat_buf);
 	}
     }
 
-  complete_pending_execs(p->pred_right);
-#else
-  /* nothing to do. */
-  return;
-#endif
+  dir_curr--;
+
+  return 1;
 }
 
 
@@ -1566,18 +1243,29 @@ complete_pending_execs(struct predicate
 static void
 process_dir (char *pathname, char *name, int pathlen, struct stat *statp, char *parent)
 {
-  char *name_space;		/* Names of files in PATHNAME. */
   int subdirs_left;		/* Number of unexamined subdirs in PATHNAME. */
-  int idx;			/* Which entry are we on? */
+  boolean subdirs_unreliable;	/* if true, cannot use dir link count as subdir limif (if false, it may STILL be unreliable) */
+  unsigned int idx;		/* Which entry are we on? */
   struct stat stat_buf;
+
   struct savedir_dirinfo *dirinfo;
-  
-  subdirs_left = statp->st_nlink - 2; /* Account for name and ".". */
 
+  if (statp->st_nlink < 2)
+    {
+      subdirs_unreliable = true;
+      subdirs_left = 0;
+    }
+  else
+    {
+      subdirs_unreliable = false; /* not necessarily right */
+      subdirs_left = statp->st_nlink - 2; /* Account for name and ".". */
+    }
+  
   errno = 0;
-  name_space = savedirinfo (name, &dirinfo);
+  dirinfo = xsavedir(name, 0);
+
   
-  if (name_space == NULL)
+  if (dirinfo == NULL)
     {
       assert(errno != 0);
       error (0, errno, "%s", pathname);
@@ -1591,7 +1279,8 @@ process_dir (char *pathname, char *name,
       unsigned cur_path_size;	/* Bytes allocated for `cur_path'. */
       register unsigned file_len; /* Length of each path to process. */
       register unsigned pathname_len; /* PATHLEN plus trailing '/'. */
-
+      boolean did_stat = false;
+      
       if (pathname[pathlen - 1] == '/')
 	pathname_len = pathlen + 1; /* For '\0'; already have '/'. */
       else
@@ -1604,11 +1293,11 @@ process_dir (char *pathname, char *name,
        * yet been processed, do them now because they must be done in
        * the same directory.
        */
-      complete_pending_execdirs(eval_tree);
+      complete_pending_execdirs(get_current_dirfd());
       
       if (strcmp (name, "."))
 	{
-	  enum SafeChdirStatus status = safely_chdir (name, TraversingDown, &stat_buf, SymlinkHandleDefault);
+	  enum SafeChdirStatus status = safely_chdir (name, TraversingDown, &stat_buf, SymlinkHandleDefault, &did_stat);
 	  switch (status)
 	    {
 	    case SafeChdirOK:
@@ -1617,9 +1306,24 @@ process_dir (char *pathname, char *name,
 	       * way back up as well, so modify our record 
 	       * of what we think we should see later.
 	       * If there was no change, the assignments are a no-op.
+	       *
+	       * However, before performing the assignment, we need to
+	       * check that we have the stat information.   If O_NOFOLLOW
+	       * is available, safely_chdir() will not have needed to use 
+	       * stat(), and so stat_buf will just contain random data.
 	       */
+	      if (!did_stat)
+		{
+		  /* If there is a link we need to follow it.  Hence 
+		   * the direct call to stat() not through (options.xstat)
+		   */
+		  set_stat_placeholders(&stat_buf);
+		  if (0 != stat(".", &stat_buf))
+		    break;	/* skip the assignment. */
+		}
 	      dir_ids[dir_curr].dev = stat_buf.st_dev;
 	      dir_ids[dir_curr].ino = stat_buf.st_ino;
+	      
 	      break;
       
 	    case SafeChdirFailWouldBeUnableToReturn:
@@ -1628,23 +1332,31 @@ process_dir (char *pathname, char *name,
 	      break;
 	      
 	    case SafeChdirFailNonexistent:
+	    case SafeChdirFailDestUnreadable:
 	    case SafeChdirFailStat:
-	    case SafeChdirFailSymlink:
 	    case SafeChdirFailNotDir:
 	    case SafeChdirFailChdirFailed:
 	      error (0, errno, "%s", pathname);
 	      state.exit_status = 1;
 	      return;
+	      
+	    case SafeChdirFailSymlink:
+	      error (0, 0,
+		     _("warning: not following the symbolic link %s"),
+		     pathname);
+	      state.exit_status = 1;
+	      return;
 	    }
 	}
 
-
-      for (idx=0, namep = name_space; *namep; namep += file_len - pathname_len + 1, ++idx)
+      for (idx=0; idx < dirinfo->size; ++idx)
 	{
 	  /* savedirinfo() may return dirinfo=NULL if extended information 
 	   * is not available. 
 	   */
-	  mode_t mode = dirinfo ? dirinfo[idx].type_info : 0;
+	  mode_t mode = (dirinfo->entries[idx].flags & SavedirHaveFileType) ? 
+	    dirinfo->entries[idx].type_info : 0;
+	  namep = dirinfo->entries[idx].name;
 
 	  /* Append this directory entry's name to the path being searched. */
 	  file_len = pathname_len + strlen (namep);
@@ -1662,7 +1374,7 @@ process_dir (char *pathname, char *name,
 	  strcpy (cur_name, namep);
 
 	  state.curdepth++;
-	  if (!options.no_leaf_check)
+	  if (!options.no_leaf_check && !subdirs_unreliable)
 	    {
 	      if (mode && S_ISDIR(mode) && (subdirs_left == 0))
 		{
@@ -1675,10 +1387,11 @@ process_dir (char *pathname, char *name,
 		   * In the latter case, -noleaf should be used routinely.
 		   */
 		  error(0, 0, _("WARNING: Hard link count is wrong for %s: this may be a bug in your filesystem driver.  Automatically turning on find's -noleaf option.  Earlier results may have failed to include directories that should have been searched."),
-			parent);
+			pathname);
 		  state.exit_status = 1; /* We know the result is wrong, now */
 		  options.no_leaf_check = true;	/* Don't make same
 						   mistake again */
+		  subdirs_unreliable = 1;
 		  subdirs_left = 1; /* band-aid for this iteration. */
 		}
 	      
@@ -1710,14 +1423,12 @@ process_dir (char *pathname, char *name,
        * yet been processed, do them now because they must be done in
        * the same directory.
        */
-      complete_pending_execdirs(eval_tree); 
-
+      complete_pending_execdirs(get_current_dirfd()); 
 
       if (strcmp (name, "."))
 	{
 	  enum SafeChdirStatus status;
 	  struct dir_id did;
-	  boolean changed = false;
 	  
 	  /* We could go back and do the next command-line arg
 	     instead, maybe using longjmp.  */
@@ -1732,7 +1443,8 @@ process_dir (char *pathname, char *name,
 	      dir = parent;
 	    }
 	  
-	  status = safely_chdir (dir, TraversingUp, &stat_buf, SymlinkHandleDefault);
+	  did_stat = false;
+	  status = safely_chdir (dir, TraversingUp, &stat_buf, SymlinkHandleDefault, &did_stat);
 	  switch (status)
 	    {
 	    case SafeChdirOK:
@@ -1743,6 +1455,7 @@ process_dir (char *pathname, char *name,
 	      return;
 	      
 	    case SafeChdirFailNonexistent:
+	    case SafeChdirFailDestUnreadable:
 	    case SafeChdirFailStat:
 	    case SafeChdirFailSymlink:
 	    case SafeChdirFailNotDir:
@@ -1765,23 +1478,14 @@ process_dir (char *pathname, char *name,
 
       if (cur_path)
 	free (cur_path);
-      free (name_space);
-      free (dirinfo);
+      free_dirinfo(dirinfo);
     }
-}
-
-/* Return true if there are no predicates with no_default_print in
-   predicate list PRED, false if there are any.
-   Returns true if default print should be performed */
 
-static boolean
-default_prints (struct predicate *pred)
-{
-  while (pred != NULL)
+  if (subdirs_unreliable)
     {
-      if (pred->no_default_print)
-	return (false);
-      pred = pred->pred_next;
+      /* Make sure we hasn't used the variable subdirs_left if we knew
+       * we shouldn't do so.
+       */
+      assert(0 == subdirs_left || options.no_leaf_check);
     }
-  return (true);
 }
Only in dbg/find6/find/find: finddata.c
Only in dbg/find6/find/find: finddata.o
Binary files dbg/find14/find/find/find.o and dbg/find6/find/find/find.o differ
diff -up -r dbg/find14/find/find/fstype.c dbg/find6/find/find/fstype.c
