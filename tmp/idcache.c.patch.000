--- dbg/find14/find/gnulib-cvs/gnulib/lib/idcache.c	2020-01-28 23:47:42.000000000 -0600
+++ dbg/find6/find/gnulib-cvs/gnulib/lib/idcache.c	2020-01-28 23:39:42.000000000 -0600
@@ -1,6 +1,7 @@
 /* idcache.c -- map user and group IDs, cached for speed
-   Copyright (C) 1985, 1988, 1989, 1990, 1997, 1998, 2003 Free Software
-   Foundation, Inc.
+
+   Copyright (C) 1985, 1988, 1989, 1990, 1997, 1998, 2003, 2005, 2006
+   Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -14,31 +15,21 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software Foundation,
-   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
 
-#if HAVE_CONFIG_H
-# include <config.h>
-#endif
+#include <config.h>
 
+#include <stddef.h>
 #include <stdio.h>
 #include <string.h>
 #include <sys/types.h>
 #include <pwd.h>
 #include <grp.h>
 
-#if HAVE_UNISTD_H
-# include <unistd.h>
-#endif
+#include <unistd.h>
 
 #include "xalloc.h"
 
-#ifndef _POSIX_VERSION
-struct passwd *getpwuid ();
-struct passwd *getpwnam ();
-struct group *getgrgid ();
-struct group *getgrnam ();
-#endif
-
 #ifdef __DJGPP__
 static char digits[] = "0123456789";
 #endif
@@ -50,13 +41,13 @@ struct userid
       uid_t u;
       gid_t g;
     } id;
-  char *name;
   struct userid *next;
+  char name[FLEXIBLE_ARRAY_MEMBER];
 };
 
 static struct userid *user_alist;
 
-/* The members of this list have names not in the local passwd file.  */
+/* Each entry on list is a user name for which the first lookup failed.  */
 static struct userid *nouser_alist;
 
 /* Translate UID to a login name, with cache, or NULL if unresolved.  */
@@ -64,22 +55,32 @@ static struct userid *nouser_alist;
 char *
 getuser (uid_t uid)
 {
-  register struct userid *tail;
-  struct passwd *pwent;
+  struct userid *tail;
+  struct userid *match = NULL;
 
   for (tail = user_alist; tail; tail = tail->next)
-    if (tail->id.u == uid)
-      return tail->name;
+    {
+      if (tail->id.u == uid)
+	{
+	  match = tail;
+	  break;
+	}
+    }
 
-  pwent = getpwuid (uid);
-  tail = xmalloc (sizeof (struct userid));
-  tail->id.u = uid;
-  tail->name = pwent ? xstrdup (pwent->pw_name) : NULL;
+  if (match == NULL)
+    {
+      struct passwd *pwent = getpwuid (uid);
+      char const *name = pwent ? pwent->pw_name : "";
+      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);
+      match->id.u = uid;
+      strcpy (match->name, name);
+
+      /* Add to the head of the list, so most recently used is first.  */
+      match->next = user_alist;
+      user_alist = match;
+    }
 
-  /* Add to the head of the list, so most recently used is first.  */
-  tail->next = user_alist;
-  user_alist = tail;
-  return tail->name;
+  return match->name[0] ? match->name : NULL;
 }
 
 /* Translate USER to a UID, with cache.
@@ -90,7 +91,7 @@ getuser (uid_t uid)
 uid_t *
 getuidbyname (const char *user)
 {
-  register struct userid *tail;
+  struct userid *tail;
   struct passwd *pwent;
 
   for (tail = user_alist; tail; tail = tail->next)
@@ -101,7 +102,7 @@ getuidbyname (const char *user)
   for (tail = nouser_alist; tail; tail = tail->next)
     /* Avoid a function call for the most common case.  */
     if (*tail->name == *user && !strcmp (tail->name, user))
-      return 0;
+      return NULL;
 
   pwent = getpwnam (user);
 #ifdef __DJGPP__
@@ -114,8 +115,8 @@ getuidbyname (const char *user)
     }
 #endif
 
-  tail = xmalloc (sizeof (struct userid));
-  tail->name = xstrdup (user);
+  tail = xmalloc (offsetof (struct userid, name) + strlen (user) + 1);
+  strcpy (tail->name, user);
 
   /* Add to the head of the list, so most recently used is first.  */
   if (pwent)
@@ -128,11 +129,13 @@ getuidbyname (const char *user)
 
   tail->next = nouser_alist;
   nouser_alist = tail;
-  return 0;
+  return NULL;
 }
 
 /* Use the same struct as for userids.  */
 static struct userid *group_alist;
+
+/* Each entry on list is a group name for which the first lookup failed.  */
 static struct userid *nogroup_alist;
 
 /* Translate GID to a group name, with cache, or NULL if unresolved.  */
@@ -140,22 +143,32 @@ static struct userid *nogroup_alist;
 char *
 getgroup (gid_t gid)
 {
-  register struct userid *tail;
-  struct group *grent;
+  struct userid *tail;
+  struct userid *match = NULL;
 
   for (tail = group_alist; tail; tail = tail->next)
-    if (tail->id.g == gid)
-      return tail->name;
+    {
+      if (tail->id.g == gid)
+	{
+	  match = tail;
+	  break;
+	}
+    }
 
-  grent = getgrgid (gid);
-  tail = xmalloc (sizeof (struct userid));
-  tail->id.g = gid;
-  tail->name = grent ? xstrdup (grent->gr_name) : NULL;
+  if (match == NULL)
+    {
+      struct group *grent = getgrgid (gid);
+      char const *name = grent ? grent->gr_name : "";
+      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);
+      match->id.g = gid;
+      strcpy (match->name, name);
+
+      /* Add to the head of the list, so most recently used is first.  */
+      match->next = group_alist;
+      group_alist = match;
+    }
 
-  /* Add to the head of the list, so most recently used is first.  */
-  tail->next = group_alist;
-  group_alist = tail;
-  return tail->name;
+  return match->name[0] ? match->name : NULL;
 }
 
 /* Translate GROUP to a GID, with cache.
@@ -166,7 +179,7 @@ getgroup (gid_t gid)
 gid_t *
 getgidbyname (const char *group)
 {
-  register struct userid *tail;
+  struct userid *tail;
   struct group *grent;
 
   for (tail = group_alist; tail; tail = tail->next)
@@ -177,12 +190,12 @@ getgidbyname (const char *group)
   for (tail = nogroup_alist; tail; tail = tail->next)
     /* Avoid a function call for the most common case.  */
     if (*tail->name == *group && !strcmp (tail->name, group))
-      return 0;
+      return NULL;
 
   grent = getgrnam (group);
 #ifdef __DJGPP__
   /* We need to pretend to belong to group GROUP, to make
-     grp functions know about any arbitrary group name.  */
+     grp functions know about an arbitrary group name.  */
   if (!grent && strspn (group, digits) < strlen (group))
     {
       setenv ("GROUP", group, 1);
@@ -190,8 +203,8 @@ getgidbyname (const char *group)
     }
 #endif
 
-  tail = xmalloc (sizeof (struct userid));
-  tail->name = xstrdup (group);
+  tail = xmalloc (offsetof (struct userid, name) + strlen (group) + 1);
+  strcpy (tail->name, group);
 
   /* Add to the head of the list, so most recently used is first.  */
   if (grent)
@@ -204,5 +217,5 @@ getgidbyname (const char *group)
 
   tail->next = nogroup_alist;
   nogroup_alist = tail;
-  return 0;
+  return NULL;
 }
Only in dbg/find6/find/gnulib-cvs/gnulib/lib: imaxabs.c
Only in dbg/find6/find/gnulib-cvs/gnulib/lib: imaxdiv.c
Only in dbg/find6/find/gnulib-cvs/gnulib/lib: inet_ntop.c
Only in dbg/find6/find/gnulib-cvs/gnulib/lib: inet_ntop.h
Only in dbg/find6/find/gnulib-cvs/gnulib/lib: inet_pton.c
Only in dbg/find6/find/gnulib-cvs/gnulib/lib: inet_pton.h
Only in dbg/find6/find/gnulib-cvs/gnulib/lib: intprops.h
diff -up -r dbg/find14/find/gnulib-cvs/gnulib/lib/inttostr.c dbg/find6/find/gnulib-cvs/gnulib/lib/inttostr.c
